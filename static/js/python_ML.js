// Do not edit this file; automatically generated by gulp.

/* eslint-disable */

var VarData = {};


(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD
        define(["./blockly_compressed.js"], factory);
    } else if (typeof exports === "object") {
        // Node.js
        module.exports = factory(require("./blockly_compressed.js"));
    } else {
        // Browser
        root.Blockly.Python = factory(root.Blockly);
    }
})(this, function (Blockly) {
    "use strict";
    Blockly.Python = new Blockly.Generator("Python");
    Blockly.Python.addReservedWords(
        "False,None,True,and,as,assert,break,class,continue,def,del,elif,else,except,exec,finally,for,from,global,if,import,in,is,lambda,nonlocal,not,or,pass,print,raise,return,try,while,with,yield,NotImplemented,Ellipsis,__debug__,quit,exit,copyright,license,credits,ArithmeticError,AssertionError,AttributeError,BaseException,BlockingIOError,BrokenPipeError,BufferError,BytesWarning,ChildProcessError,ConnectionAbortedError,ConnectionError,ConnectionRefusedError,ConnectionResetError,DeprecationWarning,EOFError,Ellipsis,EnvironmentError,Exception,FileExistsError,FileNotFoundError,FloatingPointError,FutureWarning,GeneratorExit,IOError,ImportError,ImportWarning,IndentationError,IndexError,InterruptedError,IsADirectoryError,KeyError,KeyboardInterrupt,LookupError,MemoryError,ModuleNotFoundError,NameError,NotADirectoryError,NotImplemented,NotImplementedError,OSError,OverflowError,PendingDeprecationWarning,PermissionError,ProcessLookupError,RecursionError,ReferenceError,ResourceWarning,RuntimeError,RuntimeWarning,StandardError,StopAsyncIteration,StopIteration,SyntaxError,SyntaxWarning,SystemError,SystemExit,TabError,TimeoutError,TypeError,UnboundLocalError,UnicodeDecodeError,UnicodeEncodeError,UnicodeError,UnicodeTranslateError,UnicodeWarning,UserWarning,ValueError,Warning,ZeroDivisionError,_,__build_class__,__debug__,__doc__,__import__,__loader__,__name__,__package__,__spec__,abs,all,any,apply,ascii,basestring,bin,bool,buffer,bytearray,bytes,callable,chr,classmethod,cmp,coerce,compile,complex,copyright,credits,delattr,dict,dir,divmod,enumerate,eval,exec,execfile,exit,file,filter,float,format,frozenset,getattr,globals,hasattr,hash,help,hex,id,input,int,intern,isinstance,issubclass,iter,len,license,list,locals,long,map,max,memoryview,min,next,object,oct,open,ord,pow,print,property,quit,range,raw_input,reduce,reload,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,sum,super,tuple,type,unichr,unicode,vars,xrange,zip"
    );
    Blockly.Python.VARDATA = [];
    Blockly.Python.ORDER_ATOMIC = 0;
    Blockly.Python.ORDER_COLLECTION = 1;
    Blockly.Python.ORDER_STRING_CONVERSION = 1;
    Blockly.Python.ORDER_MEMBER = 2.1;
    Blockly.Python.ORDER_FUNCTION_CALL = 2.2;
    Blockly.Python.ORDER_EXPONENTIATION = 3;
    Blockly.Python.ORDER_UNARY_SIGN = 4;
    Blockly.Python.ORDER_BITWISE_NOT = 4;
    Blockly.Python.ORDER_MULTIPLICATIVE = 5;
    Blockly.Python.ORDER_ADDITIVE = 6;
    Blockly.Python.ORDER_BITWISE_SHIFT = 7;
    Blockly.Python.ORDER_BITWISE_AND = 8;
    Blockly.Python.ORDER_BITWISE_XOR = 9;
    Blockly.Python.ORDER_BITWISE_OR = 10;
    Blockly.Python.ORDER_RELATIONAL = 11;
    Blockly.Python.ORDER_LOGICAL_NOT = 12;
    Blockly.Python.ORDER_LOGICAL_AND = 13;
    Blockly.Python.ORDER_LOGICAL_OR = 14;
    Blockly.Python.ORDER_CONDITIONAL = 15;
    Blockly.Python.ORDER_LAMBDA = 16;
    Blockly.Python.ORDER_NONE = 99;
    Blockly.Python.ORDER_OVERRIDES = [
        [Blockly.Python.ORDER_FUNCTION_CALL, Blockly.Python.ORDER_MEMBER],
        [Blockly.Python.ORDER_FUNCTION_CALL, Blockly.Python.ORDER_FUNCTION_CALL],
        [Blockly.Python.ORDER_MEMBER, Blockly.Python.ORDER_MEMBER],
        [Blockly.Python.ORDER_MEMBER, Blockly.Python.ORDER_FUNCTION_CALL],
        [Blockly.Python.ORDER_LOGICAL_NOT, Blockly.Python.ORDER_LOGICAL_NOT],
        [Blockly.Python.ORDER_LOGICAL_AND, Blockly.Python.ORDER_LOGICAL_AND],
        [Blockly.Python.ORDER_LOGICAL_OR, Blockly.Python.ORDER_LOGICAL_OR],
    ];
    Blockly.Python.isInitialized = !1;
    Blockly.Python.init = function (a) {
        Blockly.Python.PASS = this.INDENT + "pass\n";
        Blockly.Python.definitions_ = Object.create(null);
        Blockly.Python.functionNames_ = Object.create(null);
        Blockly.Python.variableDB_ ? Blockly.Python.variableDB_.reset() : (Blockly.Python.variableDB_ = new Blockly.Names(Blockly.Python.RESERVED_WORDS_));
        Blockly.Python.variableDB_.setVariableMap(a.getVariableMap());
        for (var b = [], c = Blockly.Variables.allDeveloperVariables(a), d = 0; d < c.length; d++) b.push(Blockly.Python.variableDB_.getName(c[d], Blockly.Names.DEVELOPER_VARIABLE_TYPE) + " = None");
        a = Blockly.Variables.allUsedVarModels(a);

        for (d = 0; d < a.length; d++) b.push(Blockly.Python.variableDB_.getName(a[d].getId(), Blockly.VARIABLE_CATEGORY_NAME) + " = None");
        Blockly.Python.definitions_.variables = b.join("\n");
        this.isInitialized = !0;
    };
    Blockly.Python.finish = function (a) {
        var b = [],
            c = [],
            d;
        for (d in Blockly.Python.definitions_) {
            var e = Blockly.Python.definitions_[d];
            e.match(/^(from\s+\S+\s+)?import\s+\S+/) ? b.push(e) : c.push(e);
        }
        delete Blockly.Python.definitions_;
        delete Blockly.Python.functionNames_;
        Blockly.Python.variableDB_.reset();
        return (b.join("\n") + "\n\n" + c.join("\n\n")).replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n\n\n") + a;
    };
    Blockly.Python.scrubNakedValue = function (a) {
        return a + "\n";
    };
    Blockly.Python.quote_ = function (a) {
        a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n");
        var b = "'";
        -1 !== a.indexOf("'") && (-1 === a.indexOf('"') ? (b = '"') : (a = a.replace(/'/g, "\\'")));
        return b + a + b;
    };
    Blockly.Python.multiline_quote_ = function (a) {
        return a.split(/\n/g).map(Blockly.Python.quote_).join(" + '\\n' + \n");
    };
    Blockly.Python.scrub_ = function (a, b, c) {
        var d = "";
        if (!a.outputConnection || !a.outputConnection.targetConnection) {
            var e = a.getCommentText();
            e && ((e = Blockly.utils.string.wrap(e, Blockly.Python.COMMENT_WRAP - 3)), (d += Blockly.Python.prefixLines(e + "\n", "# ")));
            for (var f = 0; f < a.inputList.length; f++) a.inputList[f].type == Blockly.INPUT_VALUE && (e = a.inputList[f].connection.targetBlock()) && (e = Blockly.Python.allNestedComments(e)) && (d += Blockly.Python.prefixLines(e, "# "));
        }
        a = a.nextConnection && a.nextConnection.targetBlock();
        c = c ? "" : Blockly.Python.blockToCode(a);
        return d + b + c;
    };
    Blockly.Python.getAdjustedInt = function (a, b, c, d) {
        c = c || 0;
        a.workspace.options.oneBasedIndex && c--;
        var e = a.workspace.options.oneBasedIndex ? "1" : "0";
        a = Blockly.Python.valueToCode(a, b, c ? Blockly.Python.ORDER_ADDITIVE : Blockly.Python.ORDER_NONE) || e;
        Blockly.isNumber(a) ? ((a = parseInt(a, 10) + c), d && (a = -a)) : ((a = 0 < c ? "int(" + a + " + " + c + ")" : 0 > c ? "int(" + a + " - " + -c + ")" : "int(" + a + ")"), d && (a = "-" + a));
        return a;
    };
    Blockly.Python.colour = {};
    Blockly.Python.colour_picker = function (a) {
        return [Blockly.Python.quote_(a.getFieldValue("COLOUR")), Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.colour_random = function (a) {
        Blockly.Python.definitions_.import_random = "import random";
        return ["'#%06x' % random.randint(0, 2**24 - 1)", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.colour_rgb = function (a) {
        var b = Blockly.Python.provideFunction_("colour_rgb", [
            "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b):",
            "  r = round(min(100, max(0, r)) * 2.55)",
            "  g = round(min(100, max(0, g)) * 2.55)",
            "  b = round(min(100, max(0, b)) * 2.55)",
            "  return '#%02x%02x%02x' % (r, g, b)",
        ]),
            c = Blockly.Python.valueToCode(a, "RED", Blockly.Python.ORDER_NONE) || 0,
            d = Blockly.Python.valueToCode(a, "GREEN", Blockly.Python.ORDER_NONE) || 0;
        a = Blockly.Python.valueToCode(a, "BLUE", Blockly.Python.ORDER_NONE) || 0;
        return [b + "(" + c + ", " + d + ", " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.colour_blend = function (a) {
        var b = Blockly.Python.provideFunction_("colour_blend", [
            "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(colour1, colour2, ratio):",
            "  r1, r2 = int(colour1[1:3], 16), int(colour2[1:3], 16)",
            "  g1, g2 = int(colour1[3:5], 16), int(colour2[3:5], 16)",
            "  b1, b2 = int(colour1[5:7], 16), int(colour2[5:7], 16)",
            "  ratio = min(1, max(0, ratio))",
            "  r = round(r1 * (1 - ratio) + r2 * ratio)",
            "  g = round(g1 * (1 - ratio) + g2 * ratio)",
            "  b = round(b1 * (1 - ratio) + b2 * ratio)",
            "  return '#%02x%02x%02x' % (r, g, b)",
        ]),
            c = Blockly.Python.valueToCode(a, "COLOUR1", Blockly.Python.ORDER_NONE) || "'#000000'",
            d = Blockly.Python.valueToCode(a, "COLOUR2", Blockly.Python.ORDER_NONE) || "'#000000'";
        a = Blockly.Python.valueToCode(a, "RATIO", Blockly.Python.ORDER_NONE) || 0;
        return [b + "(" + c + ", " + d + ", " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists = {};
    Blockly.Python.lists_create_empty = function (a) {
        return ["[]", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.lists_create_with = function (a) {
        for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) b[c] = Blockly.Python.valueToCode(a, "ADD" + c, Blockly.Python.ORDER_NONE) || "None";
        return ["[" + b.join(", ") + "]", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.lists_repeat = function (a) {
        var b = Blockly.Python.valueToCode(a, "ITEM", Blockly.Python.ORDER_NONE) || "None";
        a = Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        return ["[" + b + "] * " + a, Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.lists_length = function (a) {
        return ["len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "[]") + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists_isEmpty = function (a) {
        return ["not len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "[]") + ")", Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.lists_indexOf = function (a) {
        var b = Blockly.Python.valueToCode(a, "FIND", Blockly.Python.ORDER_NONE) || "[]",
            c = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''";
        if (a.workspace.options.oneBasedIndex)
            var d = " 0",
                e = " + 1",
                f = "";
        else (d = " -1"), (e = ""), (f = " - 1");
        if ("FIRST" == a.getFieldValue("END"))
            return (
                (a = Blockly.Python.provideFunction_("first_index", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, elem):", "  try: index = my_list.index(elem)" + e, "  except: index =" + d, "  return index"])),
                [a + "(" + c + ", " + b + ")", Blockly.Python.ORDER_FUNCTION_CALL]
            );
        a = Blockly.Python.provideFunction_("last_index", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, elem):", "  try: index = len(my_list) - my_list[::-1].index(elem)" + f, "  except: index =" + d, "  return index"]);
        return [a + "(" + c + ", " + b + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists_getIndex = function (a) {
        var b = a.getFieldValue("MODE") || "GET",
            c = a.getFieldValue("WHERE") || "FROM_START",
            d = Blockly.Python.valueToCode(a, "VALUE", "RANDOM" == c ? Blockly.Python.ORDER_NONE : Blockly.Python.ORDER_MEMBER) || "[]";
        switch (c) {
            case "FIRST":
                if ("GET" == b) return [d + "[0]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop(0)", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop(0)\n";
                break;
            case "LAST":
                if ("GET" == b) return [d + "[-1]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop()", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop()\n";
                break;
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT");
                if ("GET" == b) return [d + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop(" + a + ")\n";
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT", 1, !0);
                if ("GET" == b) return [d + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop(" + a + ")\n";
                break;
            case "RANDOM":
                Blockly.Python.definitions_.import_random = "import random";
                if ("GET" == b) return ["random.choice(" + d + ")", Blockly.Python.ORDER_FUNCTION_CALL];
                d = Blockly.Python.provideFunction_("lists_remove_random_item", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):", "  x = int(random.random() * len(myList))", "  return myList.pop(x)"]) + "(" + d + ")";
                if ("GET_REMOVE" == b) return [d, Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + "\n";
        }
        throw Error("Unhandled combination (lists_getIndex).");
    };
    Blockly.Python.lists_setIndex = function (a) {
        var b = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_MEMBER) || "[]",
            c = a.getFieldValue("MODE") || "GET",
            d = a.getFieldValue("WHERE") || "FROM_START",
            e = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "None";
        switch (d) {
            case "FIRST":
                if ("SET" == c) return b + "[0] = " + e + "\n";
                if ("INSERT" == c) return b + ".insert(0, " + e + ")\n";
                break;
            case "LAST":
                if ("SET" == c) return b + "[-1] = " + e + "\n";
                if ("INSERT" == c) return b + ".append(" + e + ")\n";
                break;
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT");
                if ("SET" == c) return b + "[" + a + "] = " + e + "\n";
                if ("INSERT" == c) return b + ".insert(" + a + ", " + e + ")\n";
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT", 1, !0);
                if ("SET" == c) return b + "[" + a + "] = " + e + "\n";
                if ("INSERT" == c) return b + ".insert(" + a + ", " + e + ")\n";
                break;
            case "RANDOM":
                Blockly.Python.definitions_.import_random = "import random";
                b.match(/^\w+$/) ? (a = "") : ((a = Blockly.Python.variableDB_.getDistinctName("tmp_list", Blockly.VARIABLE_CATEGORY_NAME)), (d = a + " = " + b + "\n"), (b = a), (a = d));
                d = Blockly.Python.variableDB_.getDistinctName("tmp_x", Blockly.VARIABLE_CATEGORY_NAME);
                a += d + " = int(random.random() * len(" + b + "))\n";
                if ("SET" == c) return a + (b + "[" + d + "] = " + e + "\n");
                if ("INSERT" == c) return a + (b + ".insert(" + d + ", " + e + ")\n");
        }
        throw Error("Unhandled combination (lists_setIndex).");
    };
    Blockly.Python.lists_getSublist = function (a) {
        var b = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_MEMBER) || "[]",
            c = a.getFieldValue("WHERE1"),
            d = a.getFieldValue("WHERE2");
        switch (c) {
            case "FROM_START":
                c = Blockly.Python.getAdjustedInt(a, "AT1");
                "0" == c && (c = "");
                break;
            case "FROM_END":
                c = Blockly.Python.getAdjustedInt(a, "AT1", 1, !0);
                break;
            case "FIRST":
                c = "";
                break;
            default:
                throw Error("Unhandled option (lists_getSublist)");
        }
        switch (d) {
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 1);
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 0, !0);
                Blockly.isNumber(String(a)) ? "0" == a && (a = "") : ((Blockly.Python.definitions_.import_sys = "import sys"), (a += " or sys.maxsize"));
                break;
            case "LAST":
                a = "";
                break;
            default:
                throw Error("Unhandled option (lists_getSublist)");
        }
        return [b + "[" + c + " : " + a + "]", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.lists_sort = function (a) {
        var b = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_NONE) || "[]",
            c = a.getFieldValue("TYPE");
        a = "1" === a.getFieldValue("DIRECTION") ? "False" : "True";
        return [
            Blockly.Python.provideFunction_("lists_sort", [
                "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, type, reverse):",
                "  def try_float(s):",
                "    try:",
                "      return float(s)",
                "    except:",
                "      return 0",
                "  key_funcs = {",
                '    "NUMERIC": try_float,',
                '    "TEXT": str,',
                '    "IGNORE_CASE": lambda s: str(s).lower()',
                "  }",
                "  key_func = key_funcs[type]",
                "  list_cpy = list(my_list)",
                "  return sorted(list_cpy, key=key_func, reverse=reverse)",
            ]) +
            "(" +
            b +
            ', "' +
            c +
            '", ' +
            a +
            ")",
            Blockly.Python.ORDER_FUNCTION_CALL,
        ];
    };
   /*
    Blockly.Python.hello_test = function (a) {
        return ["OPTION1" == a.getFieldValue("NAME") ? "print('Hesham')" : "print('Hazem')", Blockly.Python.ORDER_ATOMIC];
    };
    */
    Blockly.Python.hello = function(block) {
        var dropdown_name = block.getFieldValue('NAME');
        if (dropdown_name == 'OPTION1') {
          var code = 'print("Hesham")';
        } else if (dropdown_name == 'OPTION2') {
          var code = 'print("Hazem")';
        } else {
          var code = 'print("Abzo")';
        }
        return [code, Blockly.Python.ORDER_FUNCTION_CALL];
      };

    Blockly.Python.lists_split = function (a) {
        var b = a.getFieldValue("MODE");
        if ("SPLIT" == b) (b = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_MEMBER) || "''"), (a = Blockly.Python.valueToCode(a, "DELIM", Blockly.Python.ORDER_NONE)), (a = b + ".split(" + a + ")");
        else if ("JOIN" == b) (b = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_NONE) || "[]"), (a = Blockly.Python.valueToCode(a, "DELIM", Blockly.Python.ORDER_MEMBER) || "''"), (a = a + ".join(" + b + ")");
        else throw Error("Unknown mode: " + b);
        return [a, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists_reverse = function (a) {
        return ["list(reversed(" + (Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_NONE) || "[]") + "))", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.logic = {};
    Blockly.Python.controls_if = function (a) {
        var b = 0,
            c = "";
        Blockly.Python.STATEMENT_PREFIX && (c += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, a));
        do {
            var d = Blockly.Python.valueToCode(a, "IF" + b, Blockly.Python.ORDER_NONE) || "False";
            var e = Blockly.Python.statementToCode(a, "DO" + b) || Blockly.Python.PASS;
            Blockly.Python.STATEMENT_SUFFIX && (e = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT) + e);
            c += (0 == b ? "if " : "elif ") + d + ":\n" + e;
            ++b;
        } while (a.getInput("IF" + b));
        if (a.getInput("ELSE") || Blockly.Python.STATEMENT_SUFFIX)
            (e = Blockly.Python.statementToCode(a, "ELSE") || Blockly.Python.PASS),
                Blockly.Python.STATEMENT_SUFFIX && (e = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT) + e),
                (c += "else:\n" + e);
        return c;
    };
    Blockly.Python.controls_ifelse = Blockly.Python.controls_if;
    Blockly.Python.logic_compare = function (a) {
        var b = { EQ: "==", NEQ: "!=", LT: "<", LTE: "<=", GT: ">", GTE: ">=" }[a.getFieldValue("OP")],
            c = Blockly.Python.ORDER_RELATIONAL,
            d = Blockly.Python.valueToCode(a, "A", c) || "0";
        a = Blockly.Python.valueToCode(a, "B", c) || "0";
        return [d + " " + b + " " + a, c];
    };
    Blockly.Python.logic_operation = function (a) {
        var b = "AND" == a.getFieldValue("OP") ? "and" : "or",
            c = "and" == b ? Blockly.Python.ORDER_LOGICAL_AND : Blockly.Python.ORDER_LOGICAL_OR,
            d = Blockly.Python.valueToCode(a, "A", c);
        a = Blockly.Python.valueToCode(a, "B", c);
        if (d || a) {
            var e = "and" == b ? "True" : "False";
            d || (d = e);
            a || (a = e);
        } else a = d = "False";
        return [d + " " + b + " " + a, c];
    };
    Blockly.Python.logic_negate = function (a) {
        return ["not " + (Blockly.Python.valueToCode(a, "BOOL", Blockly.Python.ORDER_LOGICAL_NOT) || "True"), Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.logic_boolean = function (a) {
        return ["TRUE" == a.getFieldValue("BOOL") ? "True" : "False", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.logic_null = function (a) {
        return ["None", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.logic_ternary = function (a) {
        var b = Blockly.Python.valueToCode(a, "IF", Blockly.Python.ORDER_CONDITIONAL) || "False",
            c = Blockly.Python.valueToCode(a, "THEN", Blockly.Python.ORDER_CONDITIONAL) || "None";
        a = Blockly.Python.valueToCode(a, "ELSE", Blockly.Python.ORDER_CONDITIONAL) || "None";
        return [c + " if " + b + " else " + a, Blockly.Python.ORDER_CONDITIONAL];
    };
    Blockly.Python.loops = {};
    Blockly.Python.controls_repeat_ext = function (a) {
        var b = a.getField("TIMES") ? String(parseInt(a.getFieldValue("TIMES"), 10)) : Blockly.Python.valueToCode(a, "TIMES", Blockly.Python.ORDER_NONE) || "0";
        b = Blockly.isNumber(b) ? parseInt(b, 10) : "int(" + b + ")";
        var c = Blockly.Python.statementToCode(a, "DO");
        c = Blockly.Python.addLoopTrap(c, a) || Blockly.Python.PASS;
        return "for " + Blockly.Python.variableDB_.getDistinctName("count", Blockly.VARIABLE_CATEGORY_NAME) + " in range(" + b + "):\n" + c;
    };
    Blockly.Python.controls_repeat = Blockly.Python.controls_repeat_ext;
    Blockly.Python.controls_whileUntil = function (a) {
        var b = "UNTIL" == a.getFieldValue("MODE"),
            c = Blockly.Python.valueToCode(a, "BOOL", b ? Blockly.Python.ORDER_LOGICAL_NOT : Blockly.Python.ORDER_NONE) || "False",
            d = Blockly.Python.statementToCode(a, "DO");
        d = Blockly.Python.addLoopTrap(d, a) || Blockly.Python.PASS;
        b && (c = "not " + c);
        return "while " + c + ":\n" + d;
    };
    Blockly.Python.controls_for = function (a) {
        var b = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
            c = Blockly.Python.valueToCode(a, "FROM", Blockly.Python.ORDER_NONE) || "0",
            d = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "0",
            e = Blockly.Python.valueToCode(a, "BY", Blockly.Python.ORDER_NONE) || "1",
            f = Blockly.Python.statementToCode(a, "DO");
        f = Blockly.Python.addLoopTrap(f, a) || Blockly.Python.PASS;
        var n = "",
            k = function () {
                return Blockly.Python.provideFunction_("upRange", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start <= stop:", "    yield start", "    start += abs(step)"]);
            },
            h = function () {
                return Blockly.Python.provideFunction_("downRange", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start >= stop:", "    yield start", "    start -= abs(step)"]);
            };
        a = function (g, l, p) {
            return "(" + g + " <= " + l + ") and " + k() + "(" + g + ", " + l + ", " + p + ") or " + h() + "(" + g + ", " + l + ", " + p + ")";
        };
        if (Blockly.isNumber(c) && Blockly.isNumber(d) && Blockly.isNumber(e))
            (c = Number(c)),
                (d = Number(d)),
                (e = Math.abs(Number(e))),
                0 === c % 1 && 0 === d % 1 && 0 === e % 1
                    ? (c <= d ? (d++, (a = 0 == c && 1 == e ? d : c + ", " + d), 1 != e && (a += ", " + e)) : (d--, (a = c + ", " + d + ", -" + e)), (a = "range(" + a + ")"))
                    : ((a = c < d ? k() : h()), (a += "(" + c + ", " + d + ", " + e + ")"));
        else {
            var m = function (g, l) {
                Blockly.isNumber(g) ? (g = Number(g)) : g.match(/^\w+$/) ? (g = "float(" + g + ")") : ((l = Blockly.Python.variableDB_.getDistinctName(b + l, Blockly.VARIABLE_CATEGORY_NAME)), (n += l + " = float(" + g + ")\n"), (g = l));
                return g;
            };
            c = m(c, "_start");
            d = m(d, "_end");
            e = m(e, "_inc");
            "number" == typeof c && "number" == typeof d ? ((a = c < d ? k() : h()), (a += "(" + c + ", " + d + ", " + e + ")")) : (a = a(c, d, e));
        }
        return (n += "for " + b + " in " + a + ":\n" + f);
    };
    Blockly.Python.controls_forEach = function (a) {
        var b = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
            c = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_RELATIONAL) || "[]",
            d = Blockly.Python.statementToCode(a, "DO");
        d = Blockly.Python.addLoopTrap(d, a) || Blockly.Python.PASS;
        return "for " + b + " in " + c + ":\n" + d;
    };
    Blockly.Python.controls_flow_statements = function (a) {
        var b = "";
        Blockly.Python.STATEMENT_PREFIX && (b += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, a));
        Blockly.Python.STATEMENT_SUFFIX && (b += Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a));
        if (Blockly.Python.STATEMENT_PREFIX) {
            var c = Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(a);
            c && !c.suppressPrefixSuffix && (b += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, c));
        }
        switch (a.getFieldValue("FLOW")) {
            case "BREAK":
                return b + "break\n";
            case "CONTINUE":
                return b + "continue\n";
        }
        throw Error("Unknown flow statement.");
    };
    /*
     * Custom 
     */
    Blockly.Python.pandas = {};
    Blockly.Python['pandas_read_csv'] = function (a) {
        Blockly.Python.definitions_.pandas = "import pandas as pd";
        return ['pd.read_csv(' + String(a).split(" ")[2] + ')', Blockly.Python.ORDER_FUNCTION_CALL]
    }

    Blockly.Python["create_dict"] = function (a) {

        var b = 1,
            c = "{";
        do {
            var d = Blockly.Python.valueToCode(a, "KEY" + b, Blockly.Python.ORDER_NONE) || "";
            var e = Blockly.Python.valueToCode(a, "VAL" + b, Blockly.Python.ORDER_NONE) || "";
            Blockly.Python.STATEMENT_SUFFIX && (e = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT) + e);
            if (b > 1) {
                c += ",";
            }
            c += d + ":" + e;
            ++b;
        } while (a.getInput("KEY" + b));
        c += "}";
        if ((e != "") && (d != "")) {
            return [c, Blockly.Python.ORDER_FUNCTION_CALL];
        } else {
            return ["None", Blockly.Python.ORDER_FUNCTION_CALL];
        }
    }
    Blockly.Python["dict_append"] = function (a) {
        var e = ""
        var b = Blockly.Python.valueToCode(a, "DICTIONARY", Blockly.Python.ORDER_NONE) || "";
        var c = Blockly.Python.valueToCode(a, "KEY", Blockly.Python.ORDER_NONE) || "";
        var d = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "";
        if ((b != "") && (c != "") && (d != "")) {
            e = b + "[" + c + "] = " + d;
        }
        return e;
    }

    Blockly.Python['seaborn_dataset'] = function (a) {
        Blockly.Python.definitions_.seaborn = "import seaborn as sns";
        VarData[a.inputList[0].fieldRow[1].value_] = 'sns.load_dataset("' + a.inputList[0].fieldRow[1].value_ + '")', Blockly.Python.ORDER_FUNCTION_CALL;
        return ['sns.load_dataset("' + a.inputList[0].fieldRow[1].value_ + '")', Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['skl_train_test_split'] = function (a) {
        Blockly.Python.definitions_.sklearn_test_train_split = "from sklearn.model_selection import train_test_split";
        var dataframe = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_NONE) || ""
        var train_X = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME)
        var train_Y = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR2"), Blockly.VARIABLE_CATEGORY_NAME)
        var test_X = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR1"), Blockly.VARIABLE_CATEGORY_NAME)
        var test_Y = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR3"), Blockly.VARIABLE_CATEGORY_NAME)
        var target = Blockly.Python.valueToCode(a, "TARGETVAR", Blockly.Python.ORDER_NONE)
        var TestSize = Blockly.Python.valueToCode(a, "TESTSIZE", Blockly.Python.ORDER_NONE)

        var codeString = '\n' + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + '=train_test_split(' + dataframe + '.drop(columns = [' + target + ']),' + dataframe + '[' + target + ']' + ', test_size=' + TestSize + ', random_state=42)\n'
        var codeString2 = ""
        if (a.getFieldValue("SPLIT") == "dropNa") {
            codeString2 = 'def dropNa(' + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + '):\n' +
                '     ' + train_X + ' = ' + train_X + '.dropna()\n' +
                '     ' + train_Y + " = " + train_Y + ".loc[" + train_X + ".index.values.tolist()]\n" +
                '     ' + test_X + " = " + test_X + ".dropna()\n" +
                '     ' + test_Y + " = " + test_Y + ".loc[" + test_X + ".index.values.tolist()]\n" +
                '     return ' + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + '\n' +
                train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + " = " + "dropNa(" + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + ")\n"

        }


        Blockly.Python.definitions_.pandas = "import pandas as pd";
        Blockly.Python.definitions_.encoder = "from sklearn.preprocessing import LabelEncoder, OneHotEncoder";
        Blockly.Python.definitions_.numpy = "import numpy as np"

        if (dataframe == "") {
            return ""
        }
        else {
            return codeString + codeString2
        }
    }


    Blockly.Python['pandas_drop_columns'] = function (a) {
        var columns = Blockly.Python.valueToCode(a, "COLUMN", Blockly.Python.ORDER_UNARY_SIGN)
        if (columns == "") {
            return ""
        }
        var DataFrame = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_UNARY_SIGN)
        if (a.getInputTargetBlock("COLUMN").outputConnection.getCheck() == "String") {
            return [DataFrame + ".drop([" + columns + "], axis = 1)", Blockly.Python.ORDER_ATOMIC];
        } if (a.getInputTargetBlock("COLUMN").outputConnection.getCheck() == "Array") {
            return [DataFrame + ".drop([" + columns + "], axis = 1)", Blockly.Python.ORDER_ATOMIC];
        } if (columns == "" || DataFrame == "") {
            return ["", Blockly.Python.ORDER_ATOMIC];
        }
    }

    Blockly.Python['pandas_sample'] = function (a) {
        var factor = Blockly.Python.valueToCode(a, "FACTOR", Blockly.Python.ORDER_UNARY_SIGN)
        if (factor == "") {
            return ""
        }
        var DataFrame = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_UNARY_SIGN)
        if (factor != "" || DataFrame != "") {
            return [DataFrame + ".sample(frac=" + factor + ", replace=True, random_state=123)", Blockly.Python.ORDER_ATOMIC];
        }
    }


    Blockly.Python['pandas_select_columns'] = function (a) {
        var columns = Blockly.Python.valueToCode(a, "COLUMN", Blockly.Python.ORDER_UNARY_SIGN)
        if (columns == "") {
            columns = "[]"
        }
        var DataFrame = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_UNARY_SIGN)
        return [DataFrame + "[" + columns + "]", Blockly.Python.ORDER_ATOMIC];
    }

    Blockly.Python['Classification_Report'] = function (a) {
        Blockly.Python.definitions_.classification_report = "from sklearn.metrics import classification_report";
        var Pred = Blockly.Python.valueToCode(a, "Pred", Blockly.Python.ORDER_UNARY_SIGN) || "";
        var True = Blockly.Python.valueToCode(a, "True", Blockly.Python.ORDER_UNARY_SIGN) || "";
        if ((Pred != "") && (True != "")) {
            return ["classification_report(" + True + ", " + Pred + ")", Blockly.Python.ORDER_FUNCTION_CALL];
        } else {
            return ["", Blockly.Python.ORDER_FUNCTION_CALL];
        }

    }
    Blockly.Python['R2_Report'] = function (a) {
        Blockly.Python.definitions_.r2_score = "from sklearn.metrics import r2_score";
        var Pred = Blockly.Python.valueToCode(a, "Pred", Blockly.Python.ORDER_UNARY_SIGN)
        var True = Blockly.Python.valueToCode(a, "True", Blockly.Python.ORDER_UNARY_SIGN)
        if ((Pred != "") && (True != "")) {
            return ["r2_score(" + True + ", " + Pred + ")", Blockly.Python.ORDER_FUNCTION_CALL];
        } else {
            return ["", Blockly.Python.ORDER_FUNCTION_CALL];
        }
    }
    Blockly.Python['Print'] = function (a) {
        var INPUT = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_FUNCTION_CALL) || "''";
        var End = a.getFieldValue("END")

        if (End == "newLine") {
            return "print(" + INPUT + ")" + "\n";
        }
        if (End == "tab") {
            return "print(" + INPUT + ",end='\\t')" + "\n";
        }
        if (End == "space") {
            return "print(" + INPUT + ",end=' ')" + "\n";
        }
        if (End == "comma") {
            return "print(" + INPUT + ",end=',')" + "\n";
        }
    }

    Blockly.Python['pycaret_setup'] = function (a) {
        var input_data = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        var input_column = Blockly.Python.valueToCode(a, "input_column", Blockly.Python.ORDER_NONE) || "";
        var algorithm = a.getFieldValue("algorithm");

        if (input_data == "") {
            return ""
        }
        if (algorithm == "Classification") {
            Blockly.Python.definitions_.pycaret_classification = "from pycaret.classification import *";
        }
        if (algorithm == "Regression") {
            Blockly.Python.definitions_.pycaret_regression = "from pycaret.regression import *";
        }
        return "setup(" + input_data + ", target = " + input_column + ")" + "\n";


    }
    Blockly.Python['pycaret_predict'] = function (a) {
        var input_model = Blockly.Python.valueToCode(a, "input_model", Blockly.Python.ORDER_NONE) || "";
        var input_data = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        console.log(input_model)
        if (input_model == "") {
            return ["", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_model != "" && input_data == "") {
            return ["predict_model(" + input_model + ")", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_model != "" && input_data != "") {
            return ["predict_model(" + input_model + ", data=" + input_data + ")", Blockly.Python.ORDER_FUNCTION_CALL]
        }
    }
    Blockly.Python['pycaret_save'] = function (a) {

        var input_model = Blockly.Python.valueToCode(a, "input_model", Blockly.Python.ORDER_NONE) || "";
        var input_data = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        if (input_model != "" || input_data != "") {
            return "save_model(" + input_model + "," + input_data + ")" + "\n";
        }
        else {
            return ""
        }
    }

    Blockly.Python['pycaret_plot_model'] = function (a) {

        var input_model = Blockly.Python.valueToCode(a, "input_model", Blockly.Python.ORDER_NONE) || "";
        var plot_data = a.getFieldValue("plot_data");
        if (input_model != "" || plot_data != "") {
            return "plot_model(" + input_model + ", plot = '" + plot_data + "')" + "\n";
        }
        else {
            return ""
        }
    }

    Blockly.Python['pycaret_blend_model'] = function (a) {
        var input_models = Blockly.Python.valueToCode(a, "input_models", Blockly.Python.ORDER_NONE) || "";
        var input_fold = Blockly.Python.valueToCode(a, "input_fold", Blockly.Python.ORDER_NONE) || "";
        var input_method = a.getFieldValue("input_method");
        if (input_models != "" && input_fold == "") {
            return ["blend_models(" + input_models + ", method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_models != "" && input_fold != "") {
            return ["blend_models(" + input_models + " , fold = '" + input_fold + "' , method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        else {
            return ""
        }
    }

    Blockly.Python['pycaret_ensemble_model'] = function (a) {
        var input_models = Blockly.Python.valueToCode(a, "input_models", Blockly.Python.ORDER_NONE) || "";
        var input_fold = Blockly.Python.valueToCode(a, "input_fold", Blockly.Python.ORDER_NONE) || "";
        var input_method = a.getFieldValue("input_method");
        if (input_models != "" && input_fold == "") {
            return ["ensemble_model(" + input_models + ", method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_models != "" && input_fold != "") {
            return ["ensemble_model(" + input_models + " , fold = '" + input_fold + "' , method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        else {
            return ""
        }
    }
    Blockly.Python['pycaret_load'] = function (a) {
        var input_model = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        if (input_model != "") {
            return ["load_model(" + input_model + ")", Blockly.Python.ORDER_FUNCTION_CALL]

        }
        else {
            return ""
        }
    }
    Blockly.Python['pycaret_automl'] = function (a) {
        var optimizer = a.getFieldValue("optimizer");
        return ["automl(optimize = '" + optimizer + "')", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['pycaret_classifier'] = function (a) {
        var model = a.getFieldValue("model");
        return ["create_model('" + model + "')", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['pycaret_regressor'] = function (a) {
        var model = a.getFieldValue("model");
        return ["create_model('" + model + "')", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['Input'] = function (a) {
        var INPUT = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_NONE) || "''";
        return ["input(" + INPUT + ")", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['pandas_set_columns'] = function (a) {
        var columns = Blockly.Python.valueToCode(a, "COLUMN", Blockly.Python.ORDER_UNARY_SIGN)
        if (columns == "") {
            columns = "[]"
        }
        var DATAFRAME_IN = Blockly.Python.valueToCode(a, "DATAFRAME_IN", Blockly.Python.ORDER_UNARY_SIGN)
        var DATAFRAME_OUT = Blockly.Python.valueToCode(a, "DATAFRAME_OUT", Blockly.Python.ORDER_UNARY_SIGN)
        if (DATAFRAME_IN != "" || DATAFRAME_OUT != "" || columns != "") {
            return DATAFRAME_OUT + "[" + columns + "]=" + DATAFRAME_IN + "\n";
        }
        else {
            return ""
        }
    }




    Blockly.Python['dataframe_Filter'] = function (a) {
        var b = { EQ: "==", NEQ: "!=", LT: "<", LTE: "<=", GT: ">", GTE: ">=" }[a.getFieldValue("OP")];
        var c = Blockly.Python.ORDER_RELATIONAL;
        var d = Blockly.Python.valueToCode(a, "A", c) || "";
        var e = Blockly.Python.valueToCode(a, "C", c) || "";
        a = Blockly.Python.valueToCode(a, "B", c) || "";
        if (d == "" || e == "" || a == "") {
            return ["", Blockly.Python.ORDER_NONE]
        }

        return [e + "[" + d + " " + b + " " + a + "]", Blockly.Python.ORDER_FUNCTION_CALL];
    };


    Blockly.Python['dataframe_Map'] = function (a) {
        var c = Blockly.Python.ORDER_NONE;
        var b = Blockly.Python.valueToCode(a, "Map", c) || "";
        var d = Blockly.Python.valueToCode(a, "Series", c) || "";
        if (b == "" || d == "") {
            return ["", Blockly.Python.ORDER_NONE]
        }

        return [d + ".map(" + b + ")", Blockly.Python.ORDER_ATOMIC];
    };


    Blockly.Python['CLR_XGBoost'] = function (a) {
        Blockly.Python.definitions_.XGBClassifier = "from xgboost import XGBClassifier";
        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "XGBClassifier(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + ")"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "XGBClassifier()"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['REG_LinearRegression'] = function (a) {
        Blockly.Python.definitions_.LinearRegression = "from sklearn.linear_model import LinearRegression";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("REG_LinearRegression", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "Pipeline([('encoding', HandleCatagoricalData('labelEncoding')), ('scaler', StandardScaler()), ('LR', LinearRegression(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("LR", LinearRegression())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['REG_XGBRegressor'] = function (a) {
        Blockly.Python.definitions_.XGBRegressor = "from xgboost import XGBRegressor";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("REG_XGBRegressor", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])


        var codeString = ""
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "Pipeline([('encoding', HandleCatagoricalData('labelEncoding')), ('scaler', StandardScaler()), ('XGB', XGBRegressor(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("XGB", XGBRegressor())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['NN_Regression'] = function (a) {
        Blockly.Python.definitions_.XGBRegressor = "from xgboost import XGBRegressor";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("NN_Regression", [
        '    import tensorflow as tf\n'+
        '    from tensorflow.keras.models import Sequential\n'+
        '    from tensorflow.keras.layers import Dense\n'+
        '    model = Sequential()\n'+
        '    model.add(Dense(64, input_dim=${features.length}, activation="relu"))\n'+
        '    model.add(Dense(1, activation="linear"))\n'+
        '    model.compile(optimizer="adam", loss="mean_squared_error")\n'+
        '    model.fit(${features}, ${labels}, epochs=100, batch_size=32)\n'+
        '    return X\n'
        ])


        var codeString = ""
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "Pipeline([('encoding', HandleCatagoricalData('labelEncoding')), ('scaler', StandardScaler()), ('XGB', XGBRegressor(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("XGB", XGBRegressor())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['CLR_LogisticRegression'] = function (a) {
        Blockly.Python.definitions_.LogisticRegression = "from sklearn.linear_model import LogisticRegression";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_LogisticRegression", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])
        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("LR",LogisticRegression(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + '))])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("LR", LogisticRegression())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }


    Blockly.Python['CLR_NaiveBayes'] = function (a) {
        Blockly.Python.definitions_.GaussianNB = "from sklearn.naive_bayes import GaussianNB";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_NaiveBayes", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("GNB",GaussianNB())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("GNB",GaussianNB(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }
    Blockly.Python['CLR_KNN'] = function (a) {
        Blockly.Python.definitions_.KNeighborsClassifier = "from sklearn.neighbors import KNeighborsClassifier";


        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_KNN", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("KNN",KNeighborsClassifier())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("KNN",KNeighborsClassifier(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }
    Blockly.Python['CLR_DecisionTree'] = function (a) {
        Blockly.Python.definitions_.tree = "from sklearn import tree";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_DecisionTree", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])


        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("Dtree",tree.DecisionTreeClassifier(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("Dtree",tree.DecisionTreeClassifier())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }
    Blockly.Python['CLR_SVM'] = function (a) {
        Blockly.Python.definitions_.SVC = "from sklearn.svm import SVC";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_SVM", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("SVC", SVC(gamma="auto"))])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("SVC", SVC(gamma="auto"))])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }

    Blockly.Python['CLR_RandomForest'] = function (a) {
        Blockly.Python.definitions_.RandomForestClassifier = "from sklearn.ensemble import RandomForestClassifier";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_RandomForest", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("RFC", RandomForestClassifier())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("RFC", RandomForestClassifier(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + ')'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }



        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }

    Blockly.Python.math = {};
    Blockly.Python.addReservedWords("math,random,Number");
    Blockly.Python.math_number = function (a) {
        a = Number(a.getFieldValue("NUM"));

        if (Infinity == a) {
            a = 'float("inf")';
            var b = Blockly.Python.ORDER_FUNCTION_CALL;
        } else -Infinity == a ? ((a = '-float("inf")'), (b = Blockly.Python.ORDER_UNARY_SIGN)) : (b = 0 > a ? Blockly.Python.ORDER_UNARY_SIGN : Blockly.Python.ORDER_ATOMIC);
        return [a, b];
    };
    Blockly.Python.math_arithmetic = function (a) {
        var b = {
            ADD: [" + ", Blockly.Python.ORDER_ADDITIVE],
            MINUS: [" - ", Blockly.Python.ORDER_ADDITIVE],
            MULTIPLY: [" * ", Blockly.Python.ORDER_MULTIPLICATIVE],
            DIVIDE: [" / ", Blockly.Python.ORDER_MULTIPLICATIVE],
            POWER: [" ** ", Blockly.Python.ORDER_EXPONENTIATION],
        }[a.getFieldValue("OP")],
            c = b[0];
        b = b[1];
        var d = Blockly.Python.valueToCode(a, "A", b) || "0";
        a = Blockly.Python.valueToCode(a, "B", b) || "0";
        return [d + c + a, b];
    };
    Blockly.Python.math_single = function (a) {
        var b = a.getFieldValue("OP");
        if ("NEG" == b) {
            var c = Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_UNARY_SIGN) || "0";
            return ["-" + c, Blockly.Python.ORDER_UNARY_SIGN];
        }
        Blockly.Python.definitions_.import_math = "import math";
        a = "SIN" == b || "COS" == b || "TAN" == b ? Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_MULTIPLICATIVE) || "0" : Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_NONE) || "0";
        switch (b) {
            case "ABS":
                c = "math.fabs(" + a + ")";
                break;
            case "ROOT":
                c = "math.sqrt(" + a + ")";
                break;
            case "LN":
                c = "math.log(" + a + ")";
                break;
            case "LOG10":
                c = "math.log10(" + a + ")";
                break;
            case "EXP":
                c = "math.exp(" + a + ")";
                break;
            case "POW10":
                c = "math.pow(10," + a + ")";
                break;
            case "ROUND":
                c = "round(" + a + ")";
                break;
            case "ROUNDUP":
                c = "math.ceil(" + a + ")";
                break;
            case "ROUNDDOWN":
                c = "math.floor(" + a + ")";
                break;
            case "SIN":
                c = "math.sin(" + a + " / 180.0 * math.pi)";
                break;
            case "COS":
                c = "math.cos(" + a + " / 180.0 * math.pi)";
                break;
            case "TAN":
                c = "math.tan(" + a + " / 180.0 * math.pi)";
        }
        if (c) return [c, Blockly.Python.ORDER_FUNCTION_CALL];
        switch (b) {
            case "ASIN":
                c = "math.asin(" + a + ") / math.pi * 180";
                break;
            case "ACOS":
                c = "math.acos(" + a + ") / math.pi * 180";
                break;
            case "ATAN":
                c = "math.atan(" + a + ") / math.pi * 180";
                break;
            default:
                throw Error("Unknown math operator: " + b);
        }
        return [c, Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.math_constant = function (a) {
        var b = {
            PI: ["math.pi", Blockly.Python.ORDER_MEMBER],
            E: ["math.e", Blockly.Python.ORDER_MEMBER],
            GOLDEN_RATIO: ["(1 + math.sqrt(5)) / 2", Blockly.Python.ORDER_MULTIPLICATIVE],
            SQRT2: ["math.sqrt(2)", Blockly.Python.ORDER_MEMBER],
            SQRT1_2: ["math.sqrt(1.0 / 2)", Blockly.Python.ORDER_MEMBER],
            INFINITY: ["float('inf')", Blockly.Python.ORDER_ATOMIC],
        };
        a = a.getFieldValue("CONSTANT");
        "INFINITY" != a && (Blockly.Python.definitions_.import_math = "import math");
        return b[a];
    };
    Blockly.Python.math_number_property = function (a) {
        var b = Blockly.Python.valueToCode(a, "NUMBER_TO_CHECK", Blockly.Python.ORDER_MULTIPLICATIVE) || "0",
            c = a.getFieldValue("PROPERTY");
        if ("PRIME" == c)
            return (
                (Blockly.Python.definitions_.import_math = "import math"),
                (Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number"),
                [
                    Blockly.Python.provideFunction_("math_isPrime", [
                        "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(n):",
                        "  # https://en.wikipedia.org/wiki/Primality_test#Naive_methods",
                        "  # If n is not a number but a string, try parsing it.",
                        "  if not isinstance(n, Number):",
                        "    try:",
                        "      n = float(n)",
                        "    except:",
                        "      return False",
                        "  if n == 2 or n == 3:",
                        "    return True",
                        "  # False if n is negative, is 1, or not whole, or if n is divisible by 2 or 3.",
                        "  if n <= 1 or n % 1 != 0 or n % 2 == 0 or n % 3 == 0:",
                        "    return False",
                        "  # Check all the numbers of form 6k +/- 1, up to sqrt(n).",
                        "  for x in range(6, int(math.sqrt(n)) + 2, 6):",
                        "    if n % (x - 1) == 0 or n % (x + 1) == 0:",
                        "      return False",
                        "  return True",
                    ]) +
                    "(" +
                    b +
                    ")",
                    Blockly.Python.ORDER_FUNCTION_CALL,
                ]
            );
        switch (c) {
            case "EVEN":
                var d = b + " % 2 == 0";
                break;
            case "ODD":
                d = b + " % 2 == 1";
                break;
            case "WHOLE":
                d = b + " % 1 == 0";
                break;
            case "POSITIVE":
                d = b + " > 0";
                break;
            case "NEGATIVE":
                d = b + " < 0";
                break;
            case "DIVISIBLE_BY":
                a = Blockly.Python.valueToCode(a, "DIVISOR", Blockly.Python.ORDER_MULTIPLICATIVE);
                if (!a || "0" == a) return ["False", Blockly.Python.ORDER_ATOMIC];
                d = b + " % " + a + " == 0";
        }
        return [d, Blockly.Python.ORDER_RELATIONAL];
    };
    Blockly.Python.math_change = function (a) {
        Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
        var b = Blockly.Python.valueToCode(a, "DELTA", Blockly.Python.ORDER_ADDITIVE) || "0";
        a = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
        return a + " = (" + a + " if isinstance(" + a + ", Number) else 0) + " + b + "\n";
    };
    Blockly.Python.math_round = Blockly.Python.math_single;
    Blockly.Python.math_trig = Blockly.Python.math_single;
    Blockly.Python.math_on_list = function (a) {
        var b = a.getFieldValue("OP");
        a = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_NONE) || "[]";
        switch (b) {
            case "SUM":
                b = "sum(" + a + ")";
                break;
            case "MIN":
                b = "min(" + a + ")";
                break;
            case "MAX":
                b = "max(" + a + ")";
                break;
            case "AVERAGE":
                Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
                b = Blockly.Python.provideFunction_("math_mean", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):",
                    "  localList = [e for e in myList if isinstance(e, Number)]",
                    "  if not localList: return",
                    "  return float(sum(localList)) / len(localList)",
                ]);
                b = b + "(" + a + ")";
                break;
            case "MEDIAN":
                Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
                b = Blockly.Python.provideFunction_("math_median", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):",
                    "  localList = sorted([e for e in myList if isinstance(e, Number)])",
                    "  if not localList: return",
                    "  if len(localList) % 2 == 0:",
                    "    return (localList[len(localList) // 2 - 1] + localList[len(localList) // 2]) / 2.0",
                    "  else:",
                    "    return localList[(len(localList) - 1) // 2]",
                ]);
                b = b + "(" + a + ")";
                break;
            case "MODE":
                b = Blockly.Python.provideFunction_("math_modes", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(some_list):",
                    "  modes = []",
                    "  # Using a lists of [item, count] to keep count rather than dict",
                    '  # to avoid "unhashable" errors when the counted item is itself a list or dict.',
                    "  counts = []",
                    "  maxCount = 1",
                    "  for item in some_list:",
                    "    found = False",
                    "    for count in counts:",
                    "      if count[0] == item:",
                    "        count[1] += 1",
                    "        maxCount = max(maxCount, count[1])",
                    "        found = True",
                    "    if not found:",
                    "      counts.append([item, 1])",
                    "  for counted_item, item_count in counts:",
                    "    if item_count == maxCount:",
                    "      modes.append(counted_item)",
                    "  return modes",
                ]);
                b = b + "(" + a + ")";
                break;
            case "STD_DEV":
                Blockly.Python.definitions_.import_math = "import math";
                b = Blockly.Python.provideFunction_("math_standard_deviation", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(numbers):",
                    "  n = len(numbers)",
                    "  if n == 0: return",
                    "  mean = float(sum(numbers)) / n",
                    "  variance = sum((x - mean) ** 2 for x in numbers) / n",
                    "  return math.sqrt(variance)",
                ]);
                b = b + "(" + a + ")";
                break;
            case "RANDOM":
                Blockly.Python.definitions_.import_random = "import random";
                b = "random.choice(" + a + ")";
                break;
            default:
                throw Error("Unknown operator: " + b);
        }
        return [b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_modulo = function (a) {
        var b = Blockly.Python.valueToCode(a, "DIVIDEND", Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        a = Blockly.Python.valueToCode(a, "DIVISOR", Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        return [b + " % " + a, Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.math_constrain = function (a) {
        var b = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "0",
            c = Blockly.Python.valueToCode(a, "LOW", Blockly.Python.ORDER_NONE) || "0";
        a = Blockly.Python.valueToCode(a, "HIGH", Blockly.Python.ORDER_NONE) || "float('inf')";
        return ["min(max(" + b + ", " + c + "), " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_random_int = function (a) {
        Blockly.Python.definitions_.import_random = "import random";
        var b = Blockly.Python.valueToCode(a, "FROM", Blockly.Python.ORDER_NONE) || "0";
        a = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "0";
        return ["random.randint(" + b + ", " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_random_float = function (a) {
        Blockly.Python.definitions_.import_random = "import random";
        return ["random.random()", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_atan2 = function (a) {
        Blockly.Python.definitions_.import_math = "import math";
        var b = Blockly.Python.valueToCode(a, "X", Blockly.Python.ORDER_NONE) || "0";
        return ["math.atan2(" + (Blockly.Python.valueToCode(a, "Y", Blockly.Python.ORDER_NONE) || "0") + ", " + b + ") / math.pi * 180", Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.procedures = {};
    Blockly.Python.procedures_defreturn = function (a) {
        for (var b = [], c, d = a.workspace, e = Blockly.Variables.allUsedVarModels(d) || [], f = 0; (c = e[f]); f++)
            (c = c.name), -1 == a.getVars().indexOf(c) && b.push(Blockly.Python.variableDB_.getName(c, Blockly.VARIABLE_CATEGORY_NAME));
        e = Blockly.Variables.allDeveloperVariables(d);
        for (f = 0; f < e.length; f++) b.push(Blockly.Python.variableDB_.getName(e[f], Blockly.Names.DEVELOPER_VARIABLE_TYPE));
        b = b.length ? Blockly.Python.INDENT + "global " + b.join(", ") + "\n" : "";
        d = Blockly.Python.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME);
        c = "";
        Blockly.Python.STATEMENT_PREFIX && (c += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, a));
        Blockly.Python.STATEMENT_SUFFIX && (c += Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a));
        c && (c = Blockly.Python.prefixLines(c, Blockly.Python.INDENT));
        var n = "";
        Blockly.Python.INFINITE_LOOP_TRAP && (n = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.INFINITE_LOOP_TRAP, a), Blockly.Python.INDENT));
        var k = Blockly.Python.statementToCode(a, "STACK"),
            h = Blockly.Python.valueToCode(a, "RETURN", Blockly.Python.ORDER_NONE) || "",
            m = "";
        k && h && (m = c);
        h ? (h = Blockly.Python.INDENT + "return " + h + "\n") : k || (k = Blockly.Python.PASS);
        var g = [];
        e = a.getVars();
        for (f = 0; f < e.length; f++) g[f] = Blockly.Python.variableDB_.getName(e[f], Blockly.VARIABLE_CATEGORY_NAME);
        b = "def " + d + "(" + g.join(", ") + "):\n" + b + c + n + k + m + h;
        b = Blockly.Python.scrub_(a, b);
        Blockly.Python.definitions_["%" + d] = b;
        return null;
    };
    Blockly.Python.procedures_defnoreturn = Blockly.Python.procedures_defreturn;
    Blockly.Python.procedures_callreturn = function (a) {
        for (var b = Blockly.Python.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME), c = [], d = a.getVars(), e = 0; e < d.length; e++)
            c[e] = Blockly.Python.valueToCode(a, "ARG" + e, Blockly.Python.ORDER_NONE) || "None";
        return [b + "(" + c.join(", ") + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.procedures_callnoreturn = function (a) {
        return Blockly.Python.procedures_callreturn(a)[0] + "\n";
    };
    Blockly.Python.procedures_ifreturn = function (a) {
        var b = "if " + (Blockly.Python.valueToCode(a, "CONDITION", Blockly.Python.ORDER_NONE) || "False") + ":\n";
        Blockly.Python.STATEMENT_SUFFIX && (b += Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT));
        a.hasReturnValue_ ? ((a = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "None"), (b += Blockly.Python.INDENT + "return " + a + "\n")) : (b += Blockly.Python.INDENT + "return\n");
        return b;
    };
    Blockly.Python.texts = {};
    Blockly.Python.text = function (a) {
        return [Blockly.Python.quote_(a.getFieldValue("TEXT")), Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.text_multiline = function (a) {
        a = Blockly.Python.multiline_quote_(a.getFieldValue("TEXT"));
        var b = -1 != a.indexOf("+") ? Blockly.Python.ORDER_ADDITIVE : Blockly.Python.ORDER_ATOMIC;
        return [a, b];
    };
    Blockly.Python.text.forceString_ = function (a) {
        return Blockly.Python.text.forceString_.strRegExp.test(a) ? [a, Blockly.Python.ORDER_ATOMIC] : ["str(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text.forceString_.strRegExp = /^\s*'([^']|\\')*'\s*$/;
    Blockly.Python.text_join = function (a) {
        switch (a.itemCount_) {
            case 0:
                return ["''", Blockly.Python.ORDER_ATOMIC];
            case 1:
                return (a = Blockly.Python.valueToCode(a, "ADD0", Blockly.Python.ORDER_NONE) || "''"), Blockly.Python.text.forceString_(a);
            case 2:
                var b = Blockly.Python.valueToCode(a, "ADD0", Blockly.Python.ORDER_NONE) || "''";
                a = Blockly.Python.valueToCode(a, "ADD1", Blockly.Python.ORDER_NONE) || "''";
                a = Blockly.Python.text.forceString_(b)[0] + " + " + Blockly.Python.text.forceString_(a)[0];
                return [a, Blockly.Python.ORDER_ADDITIVE];
            default:
                b = [];
                for (var c = 0; c < a.itemCount_; c++) b[c] = Blockly.Python.valueToCode(a, "ADD" + c, Blockly.Python.ORDER_NONE) || "''";
                a = Blockly.Python.variableDB_.getDistinctName("x", Blockly.VARIABLE_CATEGORY_NAME);
                a = "''.join([str(" + a + ") for " + a + " in [" + b.join(", ") + "]])";
                return [a, Blockly.Python.ORDER_FUNCTION_CALL];
        }
    };
    Blockly.Python.text_append = function (a) {
        var b = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
        a = Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_NONE) || "''";
        return b + " = str(" + b + ") + " + Blockly.Python.text.forceString_(a)[0] + "\n";
    };
    Blockly.Python.text_length = function (a) {
        return ["len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''") + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_isEmpty = function (a) {
        return ["not len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''") + ")", Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.text_isEmpty2 = function (a) {
        return ["not len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''") + ")x", Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.text_indexOf = function (a) {
        var b = "FIRST" == a.getFieldValue("END") ? "find" : "rfind",
            c = Blockly.Python.valueToCode(a, "FIND", Blockly.Python.ORDER_NONE) || "''";
        b = (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_MEMBER) || "''") + "." + b + "(" + c + ")";
        return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.Python.ORDER_ADDITIVE] : [b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_charAt = function (a) {
        var b = a.getFieldValue("WHERE") || "FROM_START",
            c = Blockly.Python.valueToCode(a, "VALUE", "RANDOM" == b ? Blockly.Python.ORDER_NONE : Blockly.Python.ORDER_MEMBER) || "''";
        switch (b) {
            case "FIRST":
                return [c + "[0]", Blockly.Python.ORDER_MEMBER];
            case "LAST":
                return [c + "[-1]", Blockly.Python.ORDER_MEMBER];
            case "FROM_START":
                return (a = Blockly.Python.getAdjustedInt(a, "AT")), [c + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
            case "FROM_END":
                return (a = Blockly.Python.getAdjustedInt(a, "AT", 1, !0)), [c + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
            case "RANDOM":
                return (
                    (Blockly.Python.definitions_.import_random = "import random"),
                    [
                        Blockly.Python.provideFunction_("text_random_letter", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(text):", "  x = int(random.random() * len(text))", "  return text[x];"]) + "(" + c + ")",
                        Blockly.Python.ORDER_FUNCTION_CALL,
                    ]
                );
        }
        throw Error("Unhandled option (text_charAt).");
    };
    Blockly.Python.text_getSubstring = function (a) {
        var b = a.getFieldValue("WHERE1"),
            c = a.getFieldValue("WHERE2"),
            d = Blockly.Python.valueToCode(a, "STRING", Blockly.Python.ORDER_MEMBER) || "''";
        switch (b) {
            case "FROM_START":
                b = Blockly.Python.getAdjustedInt(a, "AT1");
                "0" == b && (b = "");
                break;
            case "FROM_END":
                b = Blockly.Python.getAdjustedInt(a, "AT1", 1, !0);
                break;
            case "FIRST":
                b = "";
                break;
            default:
                throw Error("Unhandled option (text_getSubstring)");
        }
        switch (c) {
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 1);
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 0, !0);
                Blockly.isNumber(String(a)) ? "0" == a && (a = "") : ((Blockly.Python.definitions_.import_sys = "import sys"), (a += " or sys.maxsize"));
                break;
            case "LAST":
                a = "";
                break;
            default:
                throw Error("Unhandled option (text_getSubstring)");
        }
        return [d + "[" + b + " : " + a + "]", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.text_changeCase = function (a) {
        var b = { UPPERCASE: ".upper()", LOWERCASE: ".lower()", TITLECASE: ".title()" }[a.getFieldValue("CASE")];
        return [(Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''") + b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_trim = function (a) {
        var b = { LEFT: ".lstrip()", RIGHT: ".rstrip()", BOTH: ".strip()" }[a.getFieldValue("MODE")];
        return [(Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''") + b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_print = function (a) {
        return "print(" + (Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_NONE) || "''") + ")\n";
    };
    Blockly.Python.text_prompt_ext = function (a) {
        var b = Blockly.Python.provideFunction_("text_prompt", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(msg):", "  try:", "    return raw_input(msg)", "  except NameError:", "    return input(msg)"]),
            c = a.getField("TEXT") ? Blockly.Python.quote_(a.getFieldValue("TEXT")) : Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_NONE) || "''";
        b = b + "(" + c + ")";
        "NUMBER" == a.getFieldValue("TYPE") && (b = "float(" + b + ")");
        return [b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_prompt = Blockly.Python.text_prompt_ext;
    Blockly.Python.text_count = function (a) {
        var b = Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''";
        a = Blockly.Python.valueToCode(a, "SUB", Blockly.Python.ORDER_NONE) || "''";
        return [b + ".count(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_replace = function (a) {
        var b = Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''",
            c = Blockly.Python.valueToCode(a, "FROM", Blockly.Python.ORDER_NONE) || "''";
        a = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "''";
        return [b + ".replace(" + c + ", " + a + ")", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.text_reverse = function (a) {
        return [(Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''") + "[::-1]", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.variables = {};
    Blockly.Python.variables_get = function (a) {
        return [Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME), Blockly.Python.ORDER_ATOMIC];
    };

    Blockly.Python.variables_set = function (a) {

        var b = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "0";
        if (a.getInputTargetBlock() != null){

            if (a.getInputTargetBlock("VALUE").outputConnection.getCheck() == "DataFrame") {
                VarData[Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME)] = b;
            }
    
        }
        return Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME) + " = " + b + "\n";
    };
    Blockly.Python.variablesDynamic = {};
    Blockly.Python.variables_get_dynamic = Blockly.Python.variables_get;
    Blockly.Python.variables_set_dynamic = Blockly.Python.variables_set;
    return Blockly.Python;

});
var global_predectied_variable= "y_predectied";
var input = "x";
var output = "y";
var x_train = 'X_train';
var x_test = 'X_test';
var y_train = 'y_train';
var y_test = 'y_test';
var test_size = 'test_size';

Blockly.Python['f1score'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import f1_score\nf1 = f1_score(y_test,${global_predectied_variable}) \n`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['recall'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import recall_score\nrecall =recall_score(y_test,${global_predectied_variable}) \n`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['precision'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import precision_score\nprecision = precision_score(y_test,${global_predectied_variable}) \n`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 
Blockly.Python['accuracy'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import accuracy_score\naccuracy = accuracy_score(y_test,${global_predectied_variable}) \n`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['evaluation'] = function(block) {
    var text_training_input = block.getFieldValue('predectied_variable');
    global_predectied_variable = text_training_input ;
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `${text_training_input}= model.predict(X_test) \n`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['training'] = function(block) {
    var text_training_input = block.getFieldValue('Training_input');
    var text_training_output = block.getFieldValue('Training_output');
    var code = `model.fit(${text_training_input},${text_training_output})\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['classification_models'] = function(block) {
    var dropdown_algorithm = block.getFieldValue('c_algorithms');
    var text_dataset_path = block.getFieldValue('dataset_path');
    var value_data_preprocessing = Blockly.Python.valueToCode(block, 'Data_Preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_training = Blockly.Python.valueToCode(block, 'Model_Training', Blockly.Python.ORDER_FUNCTION_CALL) || '';
    var value_model_evaluation = Blockly.Python.valueToCode(block, 'Model_Evaluation', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_prediction = Blockly.Python.valueToCode(block, 'Model_Prediction', Blockly.Python.ORDER_ATOMIC) || '';
    var value_visualization = Blockly.Python.valueToCode(block, 'Visualization', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = "";
    code += "import pandas as pd \n";
    switch (dropdown_algorithm) {
        case 'LogisticRegression':
            code += 'from sklearn.linear_model import LogisticRegression\n';
            code += 'model = LogisticRegression()\n';
            break;
        case 'Knn':
            code += 'from sklearn.neighbors import KNeighborsClassifier\n';
            code += 'model = KNeighborsClassifier()\n';
            break;
        case 'DecisionTrees':
            code += 'from sklearn.tree import DecisionTreeClassifier\n';
            code += 'model = DecisionTreeClassifier()\n';
            break;
        case 'RandomForest':
            code += 'from sklearn.ensemble import RandomForestClassifier\n';
            code += 'model = RandomForestClassifier()\n';
            break;
        case 'Svm':
            code += 'from sklearn.svm import SVC\n';
            code += 'model = SVC()\n';
            break;
        case 'NaiveBayes':
            code += 'from sklearn.naive_bayes import GaussianNB\n';
            code += 'model = GaussianNB()\n';
            break;
        case 'XGboost':
            code += 'from xgboost import XGBClassifier\n';
            code += 'model = XGBClassifier()\n';
            break;
        default:
            break;
    }
    
    code += '\n';
    code += `data = pd.read_csv('${text_dataset_path}')\n`;
    code += value_data_preprocessing + '\n';
    code += value_model_training + '\n';
    code += value_model_evaluation + '\n';
    code += value_model_prediction + '\n';
    code += value_visualization + '\n';
    return code;
};  


Blockly.Python['regression_models'] = function(block) {
    var dropdown_algorithm = block.getFieldValue('r_algorithms');
    var text_dataset_path = block.getFieldValue('dataset_path');
    var value_data_preprocessing = Blockly.Python.valueToCode(block, 'Data_Preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_training = Blockly.Python.valueToCode(block, 'Model_Training', Blockly.Python.ORDER_FUNCTION_CALL) || '';
    var value_model_evaluation = Blockly.Python.valueToCode(block, 'Model_Evaluation', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_prediction = Blockly.Python.valueToCode(block, 'Model_Prediction', Blockly.Python.ORDER_ATOMIC) || '';
    var value_visualization = Blockly.Python.valueToCode(block, 'Visualization', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = "";
    code += "import pandas as pd \n";
    switch (dropdown_algorithm) {
        case 'LinearRegression':
            code += 'from sklearn.linear_model import LinearRegression\n';
            code += 'model = LinearRegression()\n';
            break;
        case 'DecisionTreesRegressor':
            code += 'from sklearn.tree import DecisionTreeRegressor\n';
            code += 'model = DecisionTreeRegressor()\n';
            break;
        case 'RandomForestRegressor':
            code += 'from sklearn.ensemble import RandomForestRegressor\n';
            code += 'model = RandomForestRegressor()\n';
            break;
        case 'SVR':
            code += 'from sklearn.svm import SVR\n';
            code += 'model = SVR()\n';
            break;
        case 'GradientBoostingRegressor':
            code += 'from sklearn.ensemble import GradientBoostingRegressor\n';
            code += 'model = GradientBoostingRegressor()\n';
            break;
        default:
            break;
    }
    
    code += '\n';
    code += `data = pd.read_csv('${text_dataset_path}')\n`;
    code += value_data_preprocessing + '\n';
    code += value_model_training + '\n';
    code += value_model_evaluation + '\n';
    code += value_model_prediction + '\n';
    code += value_visualization + '\n';
    return code;
  }; 

Blockly.Python['mae'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code =`from sklearn.metrics import mean_absolute_error\nmae = mean_absolute_error(y_test,${global_predectied_variable})\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
Blockly.Python['mse'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = 'from sklearn.metrics import mean_squared_error\n';
    code += `mse = mean_squared_error(y_test, ${global_predectied_variable})\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['r_squared'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = 'from sklearn.metrics import r2_score\n';
    code += `r_squared = r2_score(y_test,${global_predectied_variable})\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};
Blockly.Python['sequential'] = function(block) {
    var dataset_path = block.getFieldValue('dataset_path');
    var data_preprocessing = Blockly.Python.valueToCode(block, 'data_Preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
    var layers = Blockly.Python.valueToCode(block, 'layers', Blockly.Python.ORDER_ATOMIC) || '';
    var compile = Blockly.Python.valueToCode(block, 'compile', Blockly.Python.ORDER_ATOMIC) || '';
    var fit = Blockly.Python.valueToCode(block, 'fit', Blockly.Python.ORDER_ATOMIC) || '';
    var evaluate = Blockly.Python.valueToCode(block, 'evaluate', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `import numpy as np\nimport pandas as pd\nfrom tensorflow.keras.models import Sequential\n\n`;
    if (layers) {
        code += `from tensorflow.keras.layers import Dense\n`;
    }
    code += `# Load the dataset from a CSV file\n`;
    code += `dataset_path = "${dataset_path}"\n`;
    code += `data = pd.read_csv(dataset_path)\n\n`;
    code += data_preprocessing;
    if (layers) {
        code += `model = Sequential([\n`;
        code += layers;
        code += `\n])\n`;
    }
    code += compile;
    code += fit;
    code += evaluate;
    
    return code;
};
var layersFlag = []
Blockly.Python['cnn_model'] = function(block) {
    var training_path = block.getFieldValue('training_path');
    var test_path = block.getFieldValue('test_path');

<<<<<<< HEAD
    var trainAug = Blockly.Python.valueToCode(block, 'trainAug', Blockly.Python.ORDER_ATOMIC) || '';
    var testAug = Blockly.Python.valueToCode(block, 'testAug', Blockly.Python.ORDER_ATOMIC) || '';

    var trainGen = Blockly.Python.valueToCode(block, 'trainGen', Blockly.Python.ORDER_ATOMIC) || '';
    var testGen = Blockly.Python.valueToCode(block, 'testGen', Blockly.Python.ORDER_ATOMIC) || '';

    var layers = Blockly.Python.valueToCode(block, 'layers', Blockly.Python.ORDER_ATOMIC) || '';
    var compile = Blockly.Python.valueToCode(block, 'cnnCompile', Blockly.Python.ORDER_ATOMIC) || '';
    var fit = Blockly.Python.valueToCode(block, 'cnnFit', Blockly.Python.ORDER_ATOMIC) || '';
    var evaluate = Blockly.Python.valueToCode(block, 'cnnEvaluate', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `from tensorflow.keras.models import Sequential\n`;

    if (trainAug||testAug) {
        code += `from tensorflow.keras.preprocessing.image import ImageDataGenerator\n\n`;
    }


    if(layers && layersFlag.includes("MaxPooling2D")){code+='from tensorflow.keras.layers import MaxPooling2D\n'}
    if(layers && layersFlag.includes("AveragePooling2D")){code+='from tensorflow.keras.layers import AveragePooling2D\n'}
    if(layers && layersFlag.includes("Conv2d")){code+='from tensorflow.keras.layers import Conv2D\n'}
    if(layers && layersFlag.includes("Dense")){code+='from tensorflow.keras.layers import Dense\n'}
    if(layers && layersFlag.includes("flatten")){code+='from tensorflow.keras.layers import Flatten\n'}
    if(layers && layersFlag.includes("dropout")){code+='from tensorflow.keras.layers import Dropout\n'}
    
    code += `\ntrain_dir = '${training_path}'\nvalidation_dir = '${test_path }'\n\n`
    
    if (trainAug) {
        code += `train_datagen = ImageDataGenerator( `;
        code += trainAug;
        code += `\n)\n`;
    }
    if (testAug) {
        code += `test_datagen = ImageDataGenerator(`;
        code += testAug;
        code += `\n)\n`;
    }


    if (trainGen) {
        code += `train_generator = train_datagen.flow_from_directory(train_dir,\n`;
        code += trainGen;
        code += `\n)\n`;
    }
    if (testGen) {
        code += `test_generator = test_datagen.flow_from_directory(validation_dir,\n`;
        code += testGen;
        code += `\n)\n`;
    }

    if (layers) {
        code += `model = Sequential([\n`;
        code += layers;
        code += `\n])\n`;
    }


     code += compile;
     code += fit;
     code += evaluate;
    
    return code;
};
///////////////////////////////////////////LAYERS///////////////////////////////////////////////////////   
Blockly.Python['Conv2D'] = function(block) {
    var filters = block.getFieldValue('filters');
    var size1 = block.getFieldValue('size1');
    var size2 = block.getFieldValue('size2');
    var activation = block.getFieldValue('activation');
    var input = Blockly.Python.valueToCode(block, 'Conv2D', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `Conv2D(${filters} , (${size1}, ${size2}), activation='${activation}')`;
    
    if (input) {
        code += `,\n${input}`;
      }
    if (!layersFlag.includes("Conv2d")){layersFlag.push("Conv2d")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['Conv2Dfirst'] = function(block) {
    var filters = block.getFieldValue('filters_number');
    var size1 = block.getFieldValue('f_size1');
    var size2 = block.getFieldValue('f_size2');
    var activation = block.getFieldValue('activation_function');
    var input_size1 = block.getFieldValue('input_size1');
    var input_size2 = block.getFieldValue('input_size2');
    var input_size3 = block.getFieldValue('input_size3');
    var input = Blockly.Python.valueToCode(block, 'Conv2Dfirst', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `Conv2D(${filters} , (${size1}, ${size2}), activation='${activation}',input_shape=(${input_size1}, ${input_size2}, ${input_size3 }))`;
    
    if (input) {
        code += `,\n${input}`;
      }
    if (!layersFlag.includes("Conv2d")){layersFlag.push("Conv2d")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['averagepooling2d'] = function(block) {
    var size1 = block.getFieldValue('size1');
    var size2 = block.getFieldValue('size2');
    var stride1 = block.getFieldValue('stride1');
    var stride2 = block.getFieldValue('stride2');
    var input = Blockly.Python.valueToCode(block, 'AveragePooling2D', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'AveragePooling2D(pool_size=(' + size1 + ', ' + size2 + '), strides=(' + stride1 + ', ' + stride2 + '))';
    
    if (input) {
        code += `,\n${input}`;
      }
    if (!layersFlag.includes("AveragePooling2D")){layersFlag.push("AveragePooling2D")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['maxpooling2d'] = function(block) {
    var size1 = block.getFieldValue('size1');
    var size2 = block.getFieldValue('size2');
    var stride1 = block.getFieldValue('stride1');
    var stride2 = block.getFieldValue('stride2');
    var input = Blockly.Python.valueToCode(block, 'MaxPooling2D', Blockly.Python.ORDER_ATOMIC) || '';

    var code = 'MaxPooling2D(pool_size=(' + size1 + ', ' + size2 + '), strides=(' + stride1 + ', ' + stride2 + '))';
    if (input) {
      code += `,\n${input}`;
    }

    if (!layersFlag.includes("MaxPooling2D"))
        {layersFlag.push("MaxPooling2D")}

    return [code, Blockly.Python.ORDER_ATOMIC];
  };
=======
Blockly.Python['cnn'] = function(block) {
    var dropdown_dataset = block.getFieldValue('dataset');
    var data_preprocessing = Blockly.Python.valueToCode(block, 'data_Preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
    var layers = Blockly.Python.valueToCode(block, 'layers', Blockly.Python.ORDER_ATOMIC) || '';
    var compile = Blockly.Python.valueToCode(block, 'compile', Blockly.Python.ORDER_ATOMIC) || '';
    var fit = Blockly.Python.valueToCode(block, 'fit', Blockly.Python.ORDER_ATOMIC) || '';
    var evaluate = Blockly.Python.valueToCode(block, 'evaluate', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = 'import numpy as np\nimport pandas as pd\n' +
               'from tensorflow.keras.models import Sequential\n\n'

    if (layers) {
        code += 'from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense\n\n';
    }

    var dataset = '';
    var preprocessing = '';
    switch (dropdown_dataset) {
        case 'cifar-10':
            dataset = 'cifar10';
            preprocessing = '(train_images, train_labels), (test_images, test_labels) = datasets.'+dataset+'.load_data()\n\n'+
                            '# Normalize pixel values to be between 0 and 1\n'+
                            'train_images = train_images / 255.0\n'+
                            'test_images = test_images / 255.0';
            break;
        case 'cifar-100':
            dataset = 'cifar100';
            preprocessing = '(train_images, train_labels), (test_images, test_labels) = datasets.'+dataset+'.load_data()\n\n'+
                            '# Normalize pixel values to be between 0 and 1\n'+
                            'train_images = train_images / 255.0\n'+
                            'test_images = test_images / 255.0';
            break;
        case 'mnist':
            dataset = 'mnist';
            preprocessing = '(train_images, train_labels), (test_images, test_labels) = datasets.'+dataset+'.load_data()\n\n'+
                            '# Normalize pixel values to be between 0 and 1\n'+
                            'train_images = train_images / 255.0\n'+
                            'test_images = test_images / 255.0';
            break;
        case 'fashion-mnist':
            dataset = 'fashion_mnist';
            preprocessing = '(train_images, train_labels), (test_images, test_labels) = datasets.'+dataset+'.load_data()\n\n'+
                            '# Normalize pixel values to be between 0 and 1\n'+
                            'train_images = train_images / 255.0\n'+
                            'test_images = test_images / 255.0';
            break;
        case 'imdb':
            dataset = 'imdb';
            preprocessing = '(X_train, y_train), (X_test, y_test) = datasets.'+dataset+'.load_data(num_words=max_features)'+
                            '# Pad sequences to ensure uniform length\n'+
                            'X_train = preprocessing.sequence.pad_sequences(X_train, maxlen=maxlen)\n'+
                            'X_test = preprocessing.sequence.pad_sequences(X_test, maxlen=maxlen)';
            break;
        case 'boston':
            dataset = 'boston_housing';
            preprocessing = 'from sklearn.datasets import load_boston\n' +
                            'from sklearn.model_selection import train_test_split\n' +
                            'from sklearn.preprocessing import StandardScaler\n\n' +
                            '# Load Boston Housing Prices dataset\n' +
                            'boston = load_boston()\n' +
                            'X, y = boston.data, boston.target\n\n' +
                            '# Reshape the input data to 2D array to mimic image data (assuming each feature is a "pixel")\n' +
                            'X = X.reshape(X.shape[0], X.shape[1], 1, 1)\n\n' +
                            '# Normalize features using StandardScaler\n' +
                            'scaler = StandardScaler()\n' +
                            'X = scaler.fit_transform(X)\n\n' +
                            '# Split the data into training and testing sets\n' +
                            'X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n'
            break;
        default:
            dataset = 'cifar10';
    }

    code += preprocessing;
    if (layers) {
        code += `\n\nmodel = Sequential([\n`;
        code += layers;
        code += `\n])\n`;
    }
    code += '\n'+compile;
    code += '\n'+fit;
    code += '\n'+evaluate;
    
    return code;
};

>>>>>>> 3715b06c7db1e121e0df186b2b38f4b6e8da74cd
  Blockly.Python['dense'] = function(block) {
    var neuron_number = block.getFieldValue('neuron_number');
    var activation = block.getFieldValue('activation');
    var dense_input = Blockly.Python.valueToCode(block, 'Dense', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `Dense(${neuron_number}, activation='${activation}')`;
    
    // If there is an input value, append it to the code
    if (dense_input) {
      code += `,\n${dense_input}`;
    }
    if (!layersFlag.includes("Dense")){layersFlag.push("Dense")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

<<<<<<< HEAD
  Blockly.Python['flatten'] = function(block) {
 var input = Blockly.Python.valueToCode(block, 'flatten_input', Blockly.Python.ORDER_ATOMIC) || '';

    var code = 'Flatten()';
    if (input) {
      code += `,\n${input}`;
    }

    if (!layersFlag.includes("flatten"))
        {layersFlag.push("flatten")}
=======
  Blockly.Python['conv2d'] = function(block) {
    var text_filters = block.getFieldValue('filters');
    var dropdown_filter_size = block.getFieldValue('filter_size');
    var text_activation_function = block.getFieldValue('activation function');
    var conv2d_input = Blockly.Python.valueToCode(block, 'conv2d', Blockly.Python.ORDER_ATOMIC) || '';
    var filter_size = 0;

    switch (dropdown_filter_size) {
        case '1_1':
            filter_size = 1;
            break;
        case '3_3':
            filter_size = 3;
            break;
        case '5_5':
            filter_size = 5;
            break;
        case '7_7':
            filter_size = 7;
            break;
        case '9_9':
            filter_size = 9;
            break;
        default:
            filter_size = 3;
            break;
    }
    
    if (text_filters = 'default') {
        text_filters = 32;
    }

    var code = `Conv2D(${text_filters}, (${filter_size}, ${filter_size})), activation='${text_activation_function}'), input_shape=(${text_filters}, ${text_filters}, ${filter_size}))`;
    
    // If there is an input value, append it to the code
    if (conv2d_input) {
        code += `,\n${conv2d_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['maxpooling2d'] = function(block) {
    var dropdown_maxpooling = block.getFieldValue('maxpooling');
    var maxpooling2d_input = Blockly.Python.valueToCode(block, 'maxpooling2d', Blockly.Python.ORDER_ATOMIC) || '';
    var pooling_value = 0;

    switch (dropdown_maxpooling) {
        case '2_2':
            pooling_value = 2;
            break;
        case '3_3':
            pooling_value = 3;
            break;
        case '4_4':
            pooling_value = 4;
            break;
        default:
            pooling_value = 2;
    }

    var code = `MaxPooling2D(${pooling_value}, ${pooling_value})`;

    // If there is an input value, append it to the code
    if (maxpooling2d_input) {
        code += `,\n${maxpooling2d_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['flatten'] = function(block) {
    var flatten_input = Blockly.Python.valueToCode(block, 'flatten', Blockly.Python.ORDER_ATOMIC) || '';

    var code = `Flatten()`;

    // If there is an input value, append it to the code
    if (flatten_input) {
        code += `,\n${flatten_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };


  Blockly.Python['conv2d'] = function(block) {
    var text_filters = block.getFieldValue('filters');
    var dropdown_filter_size = block.getFieldValue('filter_size');
    var text_activation_function = block.getFieldValue('activation function');
    var conv2d_input = Blockly.Python.valueToCode(block, 'conv2d', Blockly.Python.ORDER_ATOMIC) || '';
    var filter_size = 0;

    switch (dropdown_filter_size) {
        case '1_1':
            filter_size = 1;
            break;
        case '3_3':
            filter_size = 3;
            break;
        case '5_5':
            filter_size = 5;
            break;
        case '7_7':
            filter_size = 7;
            break;
        case '9_9':
            filter_size = 9;
            break;
        default:
            filter_size = 3;
            break;
    }
    
    if (text_filters = 'default') {
        text_filters = 32;
    }

    var code = `Conv2D(${text_filters}, (${filter_size}, ${filter_size})), activation='${text_activation_function}'), input_shape=(${text_filters}, ${text_filters}, ${filter_size}))`;
    
    // If there is an input value, append it to the code
    if (conv2d_input) {
        code += `,\n${conv2d_input}`;
      }
>>>>>>> 3715b06c7db1e121e0df186b2b38f4b6e8da74cd

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

<<<<<<< HEAD
  Blockly.Python['dropout'] = function(block) {
    var text_rate = block.getFieldValue('rate');
    var input = Blockly.Python.valueToCode(block, 'dropout', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `Dropout(${text_rate})`;
    if (input) {
      code += `,\n${input}`;
    }

    if (!layersFlag.includes("dropout"))
        {layersFlag.push("dropout")}

    return [code, Blockly.Python.ORDER_ATOMIC];
  };
////////////////////////////////////////////////Augmentation/////////////////////////////////////////////////
Blockly.Python['rescale'] = function(block) {
    var rescale = block.getFieldValue('rescale');
    var input = Blockly.Python.valueToCode(block, 'rescale', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `rescale= ${rescale}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['shear_range'] = function(block) {
    var shear_range = block.getFieldValue('shear_range');
    var input = Blockly.Python.valueToCode(block, 'shear_range', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `shear_range= ${ shear_range}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['zoom_range'] = function(block) {
    var zoom_range = block.getFieldValue('zoom_range');
    var input = Blockly.Python.valueToCode(block, 'zoom_range', Blockly.Python.ORDER_ATOMIC) || '';

    var code = `zoom_range= ${zoom_range}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['rotation_range'] = function(block) {
    var rotation_range = block.getFieldValue('rotation_range');
    var input = Blockly.Python.valueToCode(block, 'rotation_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `rotation_range= ${rotation_range}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['width_shift_range'] = function(block) {
    var width_shift_range = block.getFieldValue('width_shift_range');
    var input = Blockly.Python.valueToCode(block, 'width_shift_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `width_shift_range= ${width_shift_range}`;
    
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['height_shift_range'] = function(block) {
    var height_shift_range = block.getFieldValue('height_shift_range');
    var input = Blockly.Python.valueToCode(block, 'height_shift_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `height_shift_range= ${height_shift_range}`;
    
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['channel_shift_range'] = function(block) {
    var channel_shift_range = block.getFieldValue('channel_shift_range');
    var input = Blockly.Python.valueToCode(block, 'channel_shift_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `channel_shift_range= ${channel_shift_range}`;
    
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['horizontal_flip'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'horizontal_flip', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'horizontal_flip=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['vertical_flip'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'vertical_flip', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'vertical_flip=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['featurewise_center'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'featurewise_center', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'featurewise_center=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['featurewise_std_normalization'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'featurewise_std_normalization', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'featurewise_std_normalization=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['samplewise_std_normalization'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'samplewise_std_normalization', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'samplewise_std_normalization=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['samplewise_center'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'samplewise_center', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'samplewise_center=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['zca_whitening'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'zca_whitening', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'zca_whitening=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['brightness_range'] = function(block) {
    var brightness_min = block.getFieldValue('brightness_min');
    var brightness_max = block.getFieldValue('brightness_max');
    var input = Blockly.Python.valueToCode(block, 'brightness_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `brightness_range=[ ${brightness_min} , ${brightness_max} ]`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['fill_mode'] = function(block) {
    var fill_mode = block.getFieldValue('fill_mode');
    var input = Blockly.Python.valueToCode(block, 'fill_mode', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `fill_mode=${fill_mode}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
//////////////////////////////////////////////////Generators///////////////////////////////////////////////
Blockly.Python['color_mode'] = function(block) {
    var color_mode = block.getFieldValue('color_mode');
    var input = Blockly.Python.valueToCode(block, 'color_mode', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `color_mode='${color_mode}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['interpolation'] = function(block) {
    var interpolation = block.getFieldValue('interpolation');
    var input = Blockly.Python.valueToCode(block, 'interpolation', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `interpolation='${interpolation}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['subset'] = function(block) {
    var subset = block.getFieldValue('subset');
    var input = Blockly.Python.valueToCode(block, 'subset', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `subset='${subset}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['shuffle'] = function(block) {
var input = Blockly.Python.valueToCode(block, 'shuffle', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `shuffle= True`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['augment'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'augment', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `augment = True`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['save_format'] = function(block) {
    var save_format = block.getFieldValue('save_format');
    var input = Blockly.Python.valueToCode(block, 'save_format', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `save_format= '${save_format}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['seed'] = function(block) {
    var seed = block.getFieldValue('seed');
    var input = Blockly.Python.valueToCode(block, 'seed', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `seed= ${seed}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['save_to_dir'] = function(block) {
    var save_to_dir = block.getFieldValue('save_to_dir');
    var input = Blockly.Python.valueToCode(block, 'save_to_dir', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `save_to_dir= '${save_to_dir}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['save_prefix'] = function(block) {
    var save_prefix = block.getFieldValue('save_prefix');
    var input = Blockly.Python.valueToCode(block, 'save_prefix', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `save_prefix= '${save_prefix}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['class_mode'] = function(block) {
    var class_mode = block.getFieldValue('class_mode');
    var input = Blockly.Python.valueToCode(block, 'class_mode', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `class_mode = '${class_mode}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['target_size'] = function(block) {
    var target_size1 = block.getFieldValue('target_size1');
    var target_size2 = block.getFieldValue('target_size2');
    var input = Blockly.Python.valueToCode(block, 'target_size', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `target_size = (${target_size1},${target_size2})`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['batch_size'] = function(block) {
    var batch_size = block.getFieldValue('batch_size');
    var input = Blockly.Python.valueToCode(block, 'batch_size', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `batch_size = ${batch_size}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Blockly.Python['cnn'] = function(block) {
//     var dataset_path = block.getFieldValue('dataset_path');
//     var dropdown_dataset = block.getFieldValue('dataset');
//     var data_splitting = Blockly.Python.valueToCode(block, 'data_splitting', Blockly.Python.ORDER_ATOMIC) || '';
//     var layers = Blockly.Python.valueToCode(block, 'layers', Blockly.Python.ORDER_ATOMIC) || '';
//     var compile = Blockly.Python.valueToCode(block, 'compile', Blockly.Python.ORDER_ATOMIC) || '';
//     var fit = Blockly.Python.valueToCode(block, 'cnn_fit', Blockly.Python.ORDER_ATOMIC) || '';
//     var evaluate = Blockly.Python.valueToCode(block, 'evaluate', Blockly.Python.ORDER_ATOMIC) || '';
//     var function_name = '';

//     // add needed libraries
//     var code =  'import os\n' +
//                 'import numpy as np\n' +
//                 'import pandas as pd\n' +
//                 'from tensorflow.keras.models import Sequential\n' +
//                 'from keras.callbacks import EarlyStopping\n';

//     // add layers libraries
//     if (layers) {
//         code += 'from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, Embedding, LSTM\n';
//     }

//     var dataset = '';
//     switch (dropdown_dataset) {
//         case 'image':
//             function_name = 'load_image_data';
//             code += 'from keras.preprocessing import image\n' +
//                     'from keras.preprocessing.image import ImageDataGenerator\n\n' +
//                     '# Load image data\n' +
//                     'def '+function_name+'(folder_path, target_size=(224, 224)):\n' +
//                     '    images = []\n' +
//                     '    labels = []\n' +
//                     '    for root, _, files in os.walk(folder_path):\n' +
//                     '        for file in files:\n' +
//                     '            if file.lower().endswith((\'.jpg\', \'.jpeg\', \'.png\')):\n' +
//                     '                img_path = os.path.join(root, file)\n' +
//                     '                label = os.path.basename(root)\n' +
//                     '                img = image.load_img(img_path, target_size=target_size)\n' +
//                     '                img_array = image.img_to_array(img)\n' +
//                     '                images.append(img_array)\n' +
//                     '                labels.append(label)\n' +
//                     '    print("Total images loaded:", len(images))\n' +
//                     '    return np.array(images), np.array(labels)\n\n';

//             var convert_labels_code =   '# Convert labels to integers\n' +
//                                         'y_train = (y_train == "label_you_are_interested_in").astype(int)\n' +
//                                         'y_test = (y_test == "label_you_are_interested_in").astype(int)\n\n';

//             var data_augmentation =  '# Data Augmentation\n' +
//                                     'train_datagen = ImageDataGenerator(\n' +
//                                     '    rescale=1./255,\n' +
//                                     '    rotation_range=20,\n' +
//                                     '    width_shift_range=0.2,\n' +
//                                     '    height_shift_range=0.2,\n' +
//                                     '    shear_range=0.2,\n' +
//                                     '    zoom_range=0.2,\n' +
//                                     '    horizontal_flip=True\n' +
//                                     ')\n\n' +
//                                     'test_datagen = ImageDataGenerator(rescale=1./255)\n' +
//                                     'train_generator = train_datagen.flow(X_train, y_train, batch_size=32)\n' +
//                                     'test_generator = test_datagen.flow(X_test, y_test, batch_size=32)\n\n';
//             break;
//         case 'audio':
//             function_name = 'load_audio_data';
//             code += 'import librosa\n\n' +
//                     '# Load audio data\n' +
//                     'def '+function_name+'(folder_path, sample_rate=22050, duration=2):\n' +
//                     '    audio_data = []\n' +
//                     '    labels = []\n' +
//                     '    for root, _, files in os.walk(folder_path):\n' +
//                     '        for file in files:\n' +
//                     '            if file.lower().endswith(\'.wav\'):\n' +
//                     '                audio_path = os.path.join(root, file)\n' +
//                     '                label = os.path.basename(root)\n' +
//                     '                # Load audio file\n' +
//                     '                signal, sr = librosa.load(audio_path, sr=sample_rate, duration=duration, mono=True)\n' +
//                     '                # Ensure all audio files have the same length\n' +
//                     '                if len(signal) == sample_rate * duration:\n' +
//                     '                    audio_data.append(signal)\n' +
//                     '                    labels.append(label)\n' +
//                     '    print("Total audio files loaded:", len(audio_data))\n' +
//                     '    return np.array(audio_data), np.array(labels)\n\n';

//             var convert_labels_code =   '# Convert labels to integers\n' +
//                                         'unique_labels = np.unique(y_labels)\n' +
//                                         'label_to_index = {label: i for i, label in enumerate(unique_labels)}\n' +
//                                         'y_train = np.array([label_to_index[label] for label in y_train])\n' +
//                                         'y_test = np.array([label_to_index[label] for label in y_test])\n\n';
//             break;
//         case 'text':
//             function_name = 'load_text_data';
//             code += 'from keras.preprocessing.text import Tokenizer\n' +
//                     'from keras.preprocessing.sequence import pad_sequences\n\n' +
//                     '# Load text data\n' +
//                     'def '+function_name+'(folder_path, text_column, target_column):\n' +
//                     '    texts = []\n' +
//                     '    labels = []\n' +
//                     '    for file_name in os.listdir(folder_path):\n' +
//                     '        if file_name.endswith(\'.csv\'):\n' +
//                     '            file_path = os.path.join(folder_path, file_name)\n' +
//                     '            # Load the CSV file\n' +
//                     '            df = pd.read_csv(file_path)\n' +
//                     '            # Check if the target and text columns exist in the dataframe\n' +
//                     '            if text_column in df.columns and target_column in df.columns:\n' +
//                     '                # Append the text data and targets\n' +
//                     '                texts.extend(df[text_column].tolist())\n' +
//                     '                labels.extend(df[target_column].tolist())\n' +
//                     '            else:\n' +
//                     '                print(f"Warning: Columns \'{text_column}\' or \'{target_column}\' not found in file: {file_path}")\n' +
//                     '    print("Total text samples loaded:", len(texts))\n' +
//                     '    return texts, labels\n\n';

//             var convert_labels_code =   '# Tokenize text data and preprocess\n' +
//                                         'max_words = 10000  # maximum number of words to keep in the vocabulary\n' +
//                                         'max_len = 1000  # maximum length of sequences\n' +
//                                         'tokenizer = Tokenizer(num_words=max_words)\n' +
//                                         'tokenizer.fit_on_texts(texts)\n' +
//                                         'X_sequences = tokenizer.texts_to_sequences(texts)\n' +
//                                         'x = pad_sequences(X_sequences, maxlen=max_len)\n\n' +
//                                         '# Convert targets to binary labels\n' +
//                                         'y = [1 if highlight else 0 for highlight in labels]\n\n';

//             var convert_to_numpy_code = '# Convert lists to numpy arrays\n' +
//                                         'x = np.array(x)\n' +
//                                         'y = np.array(y)\n\n';

//             break;
//         default:
//             dataset = 'image';
//     }

//     // load data code
//     if (dropdown_dataset == 'image' || dropdown_dataset == 'audio') {
//         code += 'folder_path = "' + dataset_path + '/";\n' +
//                 'x, y = ' + function_name + '(folder_path);\n\n';
//     }
//     if (dropdown_dataset == 'text') {
//         code += 'folder_path = "' + dataset_path + '/";\n' +
//                 'var text_column = "enter your text column here";\n' +
//                 'var target_column = "enter your target column here";\n' +
//                 'x, y = ' + function_name + '(folder_path, text_column, target_column);\n\n';
//     }

//     // convert labels
//     if (dropdown_dataset == 'image' || dropdown_dataset == 'audio'){
//         code += convert_labels_code;
//     }else{
//         code += convert_to_numpy_code;
//     }
    

//     // add splitting code
//     code += data_splitting + '\n';

//     // add layers code
//     if (layers) {
//         code += `\n\nmodel = Sequential([\n`;
//         code += layers;
//         code += `\n])\n`;
//     }

//     code += '\n' + compile;

//     // add data augmentation
//     if (data_augmentation){
//         code += data_augmentation;
//     }

//     // add early stopping
//     code += '# Define early stopping callback\n' +
//             'early_stopping = EarlyStopping(monitor=\'val_loss\', patience=3, restore_best_weights=True)\n\n';

//     code += '\n' + fit;
//     code += '\n' + evaluate;

//     return code;
// };

// // CNN splitting
// Blockly.Python['cnn_split'] = function(block) {
//     code = '# Split data into training and testing sets\n' +
//             'X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)';
//     return [code, Blockly.Python.ORDER_ATOMIC];
// };

// // begin layers blocks

//   Blockly.Python['conv2d'] = function(block) {
//     var text_filters = block.getFieldValue('filters');
//     var dropdown_filter_size = block.getFieldValue('filter_size');
//     var text_activation_function = block.getFieldValue('activation function');
//     var conv2d_input = Blockly.Python.valueToCode(block, 'conv2d', Blockly.Python.ORDER_ATOMIC) || '';
//     var filter_size = 0;

//     switch (dropdown_filter_size) {
//         case '1_1':
//             filter_size = 1;
//             break;
//         case '3_3':
//             filter_size = 3;
//             break;
//         case '5_5':
//             filter_size = 5;
//             break;
//         case '7_7':
//             filter_size = 7;
//             break;
//         case '9_9':
//             filter_size = 9;
//             break;
//         default:
//             filter_size = 3;
//             break;
//     }
    
//     if (text_filters = 'default') {
//         text_filters = 32;
//     }

//     var code = `Conv2D(${text_filters}, (${filter_size}, ${filter_size}), activation='${text_activation_function}'), input_shape=(${text_filters}, ${text_filters}, ${filter_size}))`;
    
//     // If there is an input value, append it to the code
//     if (conv2d_input) {
//         code += `,\n${conv2d_input}`;
//       }

//     return [code, Blockly.Python.ORDER_ATOMIC];
//   };

//   Blockly.Python['conv1d'] = function(block) {
//     var text_filters = block.getFieldValue('filters');
//     var dropdown_filter_size = block.getFieldValue('filter_size');
//     var text_activation_function = block.getFieldValue('activation function');
//     var conv1d_input = Blockly.Python.valueToCode(block, 'conv1d', Blockly.Python.ORDER_ATOMIC) || '';
//     var filter_size = 0;

//     switch (dropdown_filter_size) {
//         case '1':
//             filter_size = 1;
//             break;
//         case '3':
//             filter_size = 3;
//             break;
//         case '5':
//             filter_size = 5;
//             break;
//         case '7':
//             filter_size = 7;
//             break;
//         case '9':
//             filter_size = 9;
//             break;
//         default:
//             filter_size = 3;
//             break;
//     }
    
//     if (text_filters = 'default') {
//         text_filters = 32;
//     }

//     var code = `Conv1D(${text_filters}, ${filter_size}, activation='${text_activation_function}')`;
    
//     // If there is an input value, append it to the code
//     if (conv1d_input) {
//         code += `,\n${conv1d_input}`;
//       }

//     return [code, Blockly.Python.ORDER_ATOMIC];
//   };

//   Blockly.Python['maxpooling2d'] = function(block) {
//     var dropdown_maxpooling = block.getFieldValue('maxpooling');
//     var maxpooling2d_input = Blockly.Python.valueToCode(block, 'maxpooling2d', Blockly.Python.ORDER_ATOMIC) || '';
//     var pooling_value = 0;

//     switch (dropdown_maxpooling) {
//         case '2_2':
//             pooling_value = 2;
//             break;
//         case '3_3':
//             pooling_value = 3;
//             break;
//         case '4_4':
//             pooling_value = 4;
//             break;
//         default:
//             pooling_value = 2;
//     }

//     var code = `MaxPooling2D(${pooling_value}, ${pooling_value})`;

//     // If there is an input value, append it to the code
//     if (maxpooling2d_input) {
//         code += `,\n${maxpooling2d_input}`;
//       }

//     return [code, Blockly.Python.ORDER_ATOMIC];
//   };

//   Blockly.Python['maxpooling1d'] = function(block) {
//     var dropdown_maxpooling = block.getFieldValue('maxpooling');
//     var maxpooling1d_input = Blockly.Python.valueToCode(block, 'maxpooling1d', Blockly.Python.ORDER_ATOMIC) || '';
//     var pooling_value = 0;

//     switch (dropdown_maxpooling) {
//         case '2':
//             pooling_value = 2;
//             break;
//         case '3':
//             pooling_value = 3;
//             break;
//         case '4':
//             pooling_value = 4;
//             break;
//         default:
//             pooling_value = 2;
//     }

//     var code = `MaxPooling1D(${pooling_value})`;

//     // If there is an input value, append it to the code
//     if (maxpooling1d_input) {
//         code += `,\n${maxpooling1d_input}`;
//       }

//     return [code, Blockly.Python.ORDER_ATOMIC];
//   };

//   Blockly.Python['flatten'] = function(block) {
//     var flatten_input = Blockly.Python.valueToCode(block, 'flatten', Blockly.Python.ORDER_ATOMIC) || '';

//     var code = `Flatten()`;

//     // If there is an input value, append it to the code
//     if (flatten_input) {
//         code += `,\n${flatten_input}`;
//       }

//     return [code, Blockly.Python.ORDER_ATOMIC];
//   };


//   Blockly.Python['conv2d'] = function(block) {
//     var text_filters = block.getFieldValue('filters');
//     var dropdown_filter_size = block.getFieldValue('filter_size');
//     var text_activation_function = block.getFieldValue('activation function');
//     var conv2d_input = Blockly.Python.valueToCode(block, 'conv2d', Blockly.Python.ORDER_ATOMIC) || '';
//     var filter_size = 0;

//     switch (dropdown_filter_size) {
//         case '1_1':
//             filter_size = 1;
//             break;
//         case '3_3':
//             filter_size = 3;
//             break;
//         case '5_5':
//             filter_size = 5;
//             break;
//         case '7_7':
//             filter_size = 7;
//             break;
//         case '9_9':
//             filter_size = 9;
//             break;
//         default:
//             filter_size = 3;
//             break;
//     }
    
//     if (text_filters = 'default') {
//         text_filters = 32;
//     }

//     var code = `Conv2D(${text_filters}, (${filter_size}, ${filter_size})), activation='${text_activation_function}'), input_shape=(${text_filters}, ${text_filters}, ${filter_size}))`;
    
//     // If there is an input value, append it to the code
//     if (conv2d_input) {
//         code += `,\n${conv2d_input}`;
//       }

//     return [code, Blockly.Python.ORDER_ATOMIC];
//   };
//   // end layers blocks

//   // begin Model Evaluation blocks
/////////////////////////////////// FITING //////////////////////////////////////////////////////////
=======
>>>>>>> 3715b06c7db1e121e0df186b2b38f4b6e8da74cd
  Blockly.Python['fit'] = function(block) {
    var x_train = block.getFieldValue('X_train');
    var y_train = block.getFieldValue('y_train');
    var epochs = block.getFieldValue('epochs');
    var verbose = block.getFieldValue('verbose');
  
    var code = `model.fit(${x_train}, ${y_train}, epochs=${epochs}, verbose=${verbose})\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['cnn_fit'] = function(block) {
    var epochs = block.getFieldValue('cnn_epochs');
    var verbose = block.getFieldValue('cnn_verbose');
  
    var code = `model.fit(train_generator, epochs=${epochs}, verbose=${verbose})\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

//   Blockly.Python['cnn_fit'] = function(block) {
//     var dropdown_cnn_fit = block.getFieldValue('cnn_fit_dropdown');

//     switch (dropdown_cnn_fit) {
//         case 'text_audio':
//             var code =  '# Fit the model with early stopping\n' +
//                     'history = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test), callbacks=[early_stopping])\n';
//             break;
//         case 'image':
//             var code =  '# Fit the model with early stopping\n' +
//                     'history = model.fit(train_generator, epochs=20, validation_data=test_generator, callbacks=[early_stopping])\n';
//             break;
//     }
//     return [code, Blockly.Python.ORDER_ATOMIC];
//   };
  /////////////////////////////////EVALUATION ////////////////////////////////////////////////
  Blockly.Python['evaluate'] = function(block) {
    var x_test = block.getFieldValue('X_test');
    var y_test = block.getFieldValue('y_test');
  
    var code = `model.evaluate(${x_test}, ${y_test})\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['cnn_evaluation'] = function(block) {
    var code = `model.evaluate(test_generator)\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  
     Blockly.Python['compile'] = function(block) {
    var optimizer = block.getFieldValue('optimizer');
    var loss = block.getFieldValue('loss');
    var metrics = block.getFieldValue('metrics');
  
    var code = `model.compile(optimizer='${optimizer}', loss='${loss}', metrics=['${metrics}'])\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
Blockly.Python['data_split'] = function(block) {
    x_train = block.getFieldValue('X_train');
    x_test = block.getFieldValue('X_test');
    y_train = block.getFieldValue('y_train');
    y_test = block.getFieldValue('y_test');
    test_size = block.getFieldValue('test_size');
    var code = 'from sklearn.model_selection import train_test_split;\n'
    code += `${x_train}, ${x_test}, ${y_train}, ${y_test} = train_test_split(${input}, ${output}, test_size=${test_size}, random_state=42);\n`
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['input_output'] = function(block) {
    var value_preprocessing = Blockly.Python.valueToCode(block,'input_output', Blockly.Python.ORDER_ATOMIC) || '';
    input = block.getFieldValue('input_variable');
    output = block.getFieldValue('output_variable');
    var target_column = block.getFieldValue('target_column');

    var code = `${input} = data.drop(columns=['${target_column}'], axis=1);\n`
    code += `${output} = data['${target_column}'];\n`
    code += value_preprocessing + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};


