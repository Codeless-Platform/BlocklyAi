// Do not edit this file; automatically generated by gulp.

/* eslint-disable */

var VarData = {};


(function (root, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD
        define(["./blockly_compressed.js"], factory);
    } else if (typeof exports === "object") {
        // Node.js
        module.exports = factory(require("./blockly_compressed.js"));
    } else {
        // Browser
        root.Blockly.Python = factory(root.Blockly);
    }
})(this, function (Blockly) {
    "use strict";
    Blockly.Python = new Blockly.Generator("Python");
    Blockly.Python.addReservedWords(
        "False,None,True,and,as,assert,break,class,continue,def,del,elif,else,except,exec,finally,for,from,global,if,import,in,is,lambda,nonlocal,not,or,pass,print,raise,return,try,while,with,yield,NotImplemented,Ellipsis,__debug__,quit,exit,copyright,license,credits,ArithmeticError,AssertionError,AttributeError,BaseException,BlockingIOError,BrokenPipeError,BufferError,BytesWarning,ChildProcessError,ConnectionAbortedError,ConnectionError,ConnectionRefusedError,ConnectionResetError,DeprecationWarning,EOFError,Ellipsis,EnvironmentError,Exception,FileExistsError,FileNotFoundError,FloatingPointError,FutureWarning,GeneratorExit,IOError,ImportError,ImportWarning,IndentationError,IndexError,InterruptedError,IsADirectoryError,KeyError,KeyboardInterrupt,LookupError,MemoryError,ModuleNotFoundError,NameError,NotADirectoryError,NotImplemented,NotImplementedError,OSError,OverflowError,PendingDeprecationWarning,PermissionError,ProcessLookupError,RecursionError,ReferenceError,ResourceWarning,RuntimeError,RuntimeWarning,StandardError,StopAsyncIteration,StopIteration,SyntaxError,SyntaxWarning,SystemError,SystemExit,TabError,TimeoutError,TypeError,UnboundLocalError,UnicodeDecodeError,UnicodeEncodeError,UnicodeError,UnicodeTranslateError,UnicodeWarning,UserWarning,ValueError,Warning,ZeroDivisionError,_,__build_class__,__debug__,__doc__,__import__,__loader__,__name__,__package__,__spec__,abs,all,any,apply,ascii,basestring,bin,bool,buffer,bytearray,bytes,callable,chr,classmethod,cmp,coerce,compile,complex,copyright,credits,delattr,dict,dir,divmod,enumerate,eval,exec,execfile,exit,file,filter,float,format,frozenset,getattr,globals,hasattr,hash,help,hex,id,input,int,intern,isinstance,issubclass,iter,len,license,list,locals,long,map,max,memoryview,min,next,object,oct,open,ord,pow,print,property,quit,range,raw_input,reduce,reload,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,sum,super,tuple,type,unichr,unicode,vars,xrange,zip"
    );
    Blockly.Python.VARDATA = [];
    Blockly.Python.ORDER_ATOMIC = 0;
    Blockly.Python.ORDER_COLLECTION = 1;
    Blockly.Python.ORDER_STRING_CONVERSION = 1;
    Blockly.Python.ORDER_MEMBER = 2.1;
    Blockly.Python.ORDER_FUNCTION_CALL = 2.2;
    Blockly.Python.ORDER_EXPONENTIATION = 3;
    Blockly.Python.ORDER_UNARY_SIGN = 4;
    Blockly.Python.ORDER_BITWISE_NOT = 4;
    Blockly.Python.ORDER_MULTIPLICATIVE = 5;
    Blockly.Python.ORDER_ADDITIVE = 6;
    Blockly.Python.ORDER_BITWISE_SHIFT = 7;
    Blockly.Python.ORDER_BITWISE_AND = 8;
    Blockly.Python.ORDER_BITWISE_XOR = 9;
    Blockly.Python.ORDER_BITWISE_OR = 10;
    Blockly.Python.ORDER_RELATIONAL = 11;
    Blockly.Python.ORDER_LOGICAL_NOT = 12;
    Blockly.Python.ORDER_LOGICAL_AND = 13;
    Blockly.Python.ORDER_LOGICAL_OR = 14;
    Blockly.Python.ORDER_CONDITIONAL = 15;
    Blockly.Python.ORDER_LAMBDA = 16;
    Blockly.Python.ORDER_NONE = 99;
    Blockly.Python.ORDER_OVERRIDES = [
        [Blockly.Python.ORDER_FUNCTION_CALL, Blockly.Python.ORDER_MEMBER],
        [Blockly.Python.ORDER_FUNCTION_CALL, Blockly.Python.ORDER_FUNCTION_CALL],
        [Blockly.Python.ORDER_MEMBER, Blockly.Python.ORDER_MEMBER],
        [Blockly.Python.ORDER_MEMBER, Blockly.Python.ORDER_FUNCTION_CALL],
        [Blockly.Python.ORDER_LOGICAL_NOT, Blockly.Python.ORDER_LOGICAL_NOT],
        [Blockly.Python.ORDER_LOGICAL_AND, Blockly.Python.ORDER_LOGICAL_AND],
        [Blockly.Python.ORDER_LOGICAL_OR, Blockly.Python.ORDER_LOGICAL_OR],
    ];
    Blockly.Python.isInitialized = !1;
    Blockly.Python.init = function (a) {
        Blockly.Python.PASS = this.INDENT + "pass\n";
        Blockly.Python.definitions_ = Object.create(null);
        Blockly.Python.functionNames_ = Object.create(null);
        Blockly.Python.variableDB_ ? Blockly.Python.variableDB_.reset() : (Blockly.Python.variableDB_ = new Blockly.Names(Blockly.Python.RESERVED_WORDS_));
        Blockly.Python.variableDB_.setVariableMap(a.getVariableMap());
        for (var b = [], c = Blockly.Variables.allDeveloperVariables(a), d = 0; d < c.length; d++) b.push(Blockly.Python.variableDB_.getName(c[d], Blockly.Names.DEVELOPER_VARIABLE_TYPE) + " = None");
        a = Blockly.Variables.allUsedVarModels(a);

        for (d = 0; d < a.length; d++) b.push(Blockly.Python.variableDB_.getName(a[d].getId(), Blockly.VARIABLE_CATEGORY_NAME) + " = None");
        Blockly.Python.definitions_.variables = b.join("\n");
        this.isInitialized = !0;
    };
    Blockly.Python.finish = function (a) {
        var b = [],
            c = [],
            d;
        for (d in Blockly.Python.definitions_) {
            var e = Blockly.Python.definitions_[d];
            e.match(/^(from\s+\S+\s+)?import\s+\S+/) ? b.push(e) : c.push(e);
        }
        delete Blockly.Python.definitions_;
        delete Blockly.Python.functionNames_;
        Blockly.Python.variableDB_.reset();
        return (b.join("\n") + "\n\n" + c.join("\n\n")).replace(/\n\n+/g, "\n\n").replace(/\n*$/, "\n\n\n") + a;
    };
    Blockly.Python.scrubNakedValue = function (a) {
        return a + "\n";
    };
    Blockly.Python.quote_ = function (a) {
        a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n");
        var b = "'";
        -1 !== a.indexOf("'") && (-1 === a.indexOf('"') ? (b = '"') : (a = a.replace(/'/g, "\\'")));
        return b + a + b;
    };
    Blockly.Python.multiline_quote_ = function (a) {
        return a.split(/\n/g).map(Blockly.Python.quote_).join(" + '\\n' + \n");
    };
    Blockly.Python.scrub_ = function (a, b, c) {
        var d = "";
        if (!a.outputConnection || !a.outputConnection.targetConnection) {
            var e = a.getCommentText();
            e && ((e = Blockly.utils.string.wrap(e, Blockly.Python.COMMENT_WRAP - 3)), (d += Blockly.Python.prefixLines(e + "\n", "# ")));
            for (var f = 0; f < a.inputList.length; f++) a.inputList[f].type == Blockly.INPUT_VALUE && (e = a.inputList[f].connection.targetBlock()) && (e = Blockly.Python.allNestedComments(e)) && (d += Blockly.Python.prefixLines(e, "# "));
        }
        a = a.nextConnection && a.nextConnection.targetBlock();
        c = c ? "" : Blockly.Python.blockToCode(a);
        return d + b + c;
    };
    Blockly.Python.getAdjustedInt = function (a, b, c, d) {
        c = c || 0;
        a.workspace.options.oneBasedIndex && c--;
        var e = a.workspace.options.oneBasedIndex ? "1" : "0";
        a = Blockly.Python.valueToCode(a, b, c ? Blockly.Python.ORDER_ADDITIVE : Blockly.Python.ORDER_NONE) || e;
        Blockly.isNumber(a) ? ((a = parseInt(a, 10) + c), d && (a = -a)) : ((a = 0 < c ? "int(" + a + " + " + c + ")" : 0 > c ? "int(" + a + " - " + -c + ")" : "int(" + a + ")"), d && (a = "-" + a));
        return a;
    };
    Blockly.Python.colour = {};
    Blockly.Python.colour_picker = function (a) {
        return [Blockly.Python.quote_(a.getFieldValue("COLOUR")), Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.colour_random = function (a) {
        Blockly.Python.definitions_.import_random = "import random";
        return ["'#%06x' % random.randint(0, 2**24 - 1)", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.colour_rgb = function (a) {
        var b = Blockly.Python.provideFunction_("colour_rgb", [
            "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b):",
            "  r = round(min(100, max(0, r)) * 2.55)",
            "  g = round(min(100, max(0, g)) * 2.55)",
            "  b = round(min(100, max(0, b)) * 2.55)",
            "  return '#%02x%02x%02x' % (r, g, b)",
        ]),
            c = Blockly.Python.valueToCode(a, "RED", Blockly.Python.ORDER_NONE) || 0,
            d = Blockly.Python.valueToCode(a, "GREEN", Blockly.Python.ORDER_NONE) || 0;
        a = Blockly.Python.valueToCode(a, "BLUE", Blockly.Python.ORDER_NONE) || 0;
        return [b + "(" + c + ", " + d + ", " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.colour_blend = function (a) {
        var b = Blockly.Python.provideFunction_("colour_blend", [
            "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(colour1, colour2, ratio):",
            "  r1, r2 = int(colour1[1:3], 16), int(colour2[1:3], 16)",
            "  g1, g2 = int(colour1[3:5], 16), int(colour2[3:5], 16)",
            "  b1, b2 = int(colour1[5:7], 16), int(colour2[5:7], 16)",
            "  ratio = min(1, max(0, ratio))",
            "  r = round(r1 * (1 - ratio) + r2 * ratio)",
            "  g = round(g1 * (1 - ratio) + g2 * ratio)",
            "  b = round(b1 * (1 - ratio) + b2 * ratio)",
            "  return '#%02x%02x%02x' % (r, g, b)",
        ]),
            c = Blockly.Python.valueToCode(a, "COLOUR1", Blockly.Python.ORDER_NONE) || "'#000000'",
            d = Blockly.Python.valueToCode(a, "COLOUR2", Blockly.Python.ORDER_NONE) || "'#000000'";
        a = Blockly.Python.valueToCode(a, "RATIO", Blockly.Python.ORDER_NONE) || 0;
        return [b + "(" + c + ", " + d + ", " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists = {};
    Blockly.Python.lists_create_empty = function (a) {
        return ["[]", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.lists_create_with = function (a) {
        for (var b = Array(a.itemCount_), c = 0; c < a.itemCount_; c++) b[c] = Blockly.Python.valueToCode(a, "ADD" + c, Blockly.Python.ORDER_NONE) || "None";
        return ["[" + b.join(", ") + "]", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.lists_repeat = function (a) {
        var b = Blockly.Python.valueToCode(a, "ITEM", Blockly.Python.ORDER_NONE) || "None";
        a = Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        return ["[" + b + "] * " + a, Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.lists_length = function (a) {
        return ["len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "[]") + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists_isEmpty = function (a) {
        return ["not len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "[]") + ")", Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.lists_indexOf = function (a) {
        var b = Blockly.Python.valueToCode(a, "FIND", Blockly.Python.ORDER_NONE) || "[]",
            c = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''";
        if (a.workspace.options.oneBasedIndex)
            var d = " 0",
                e = " + 1",
                f = "";
        else (d = " -1"), (e = ""), (f = " - 1");
        if ("FIRST" == a.getFieldValue("END"))
            return (
                (a = Blockly.Python.provideFunction_("first_index", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, elem):", "  try: index = my_list.index(elem)" + e, "  except: index =" + d, "  return index"])),
                [a + "(" + c + ", " + b + ")", Blockly.Python.ORDER_FUNCTION_CALL]
            );
        a = Blockly.Python.provideFunction_("last_index", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, elem):", "  try: index = len(my_list) - my_list[::-1].index(elem)" + f, "  except: index =" + d, "  return index"]);
        return [a + "(" + c + ", " + b + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists_getIndex = function (a) {
        var b = a.getFieldValue("MODE") || "GET",
            c = a.getFieldValue("WHERE") || "FROM_START",
            d = Blockly.Python.valueToCode(a, "VALUE", "RANDOM" == c ? Blockly.Python.ORDER_NONE : Blockly.Python.ORDER_MEMBER) || "[]";
        switch (c) {
            case "FIRST":
                if ("GET" == b) return [d + "[0]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop(0)", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop(0)\n";
                break;
            case "LAST":
                if ("GET" == b) return [d + "[-1]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop()", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop()\n";
                break;
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT");
                if ("GET" == b) return [d + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop(" + a + ")\n";
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT", 1, !0);
                if ("GET" == b) return [d + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
                if ("GET_REMOVE" == b) return [d + ".pop(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + ".pop(" + a + ")\n";
                break;
            case "RANDOM":
                Blockly.Python.definitions_.import_random = "import random";
                if ("GET" == b) return ["random.choice(" + d + ")", Blockly.Python.ORDER_FUNCTION_CALL];
                d = Blockly.Python.provideFunction_("lists_remove_random_item", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):", "  x = int(random.random() * len(myList))", "  return myList.pop(x)"]) + "(" + d + ")";
                if ("GET_REMOVE" == b) return [d, Blockly.Python.ORDER_FUNCTION_CALL];
                if ("REMOVE" == b) return d + "\n";
        }
        throw Error("Unhandled combination (lists_getIndex).");
    };
    Blockly.Python.lists_setIndex = function (a) {
        var b = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_MEMBER) || "[]",
            c = a.getFieldValue("MODE") || "GET",
            d = a.getFieldValue("WHERE") || "FROM_START",
            e = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "None";
        switch (d) {
            case "FIRST":
                if ("SET" == c) return b + "[0] = " + e + "\n";
                if ("INSERT" == c) return b + ".insert(0, " + e + ")\n";
                break;
            case "LAST":
                if ("SET" == c) return b + "[-1] = " + e + "\n";
                if ("INSERT" == c) return b + ".append(" + e + ")\n";
                break;
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT");
                if ("SET" == c) return b + "[" + a + "] = " + e + "\n";
                if ("INSERT" == c) return b + ".insert(" + a + ", " + e + ")\n";
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT", 1, !0);
                if ("SET" == c) return b + "[" + a + "] = " + e + "\n";
                if ("INSERT" == c) return b + ".insert(" + a + ", " + e + ")\n";
                break;
            case "RANDOM":
                Blockly.Python.definitions_.import_random = "import random";
                b.match(/^\w+$/) ? (a = "") : ((a = Blockly.Python.variableDB_.getDistinctName("tmp_list", Blockly.VARIABLE_CATEGORY_NAME)), (d = a + " = " + b + "\n"), (b = a), (a = d));
                d = Blockly.Python.variableDB_.getDistinctName("tmp_x", Blockly.VARIABLE_CATEGORY_NAME);
                a += d + " = int(random.random() * len(" + b + "))\n";
                if ("SET" == c) return a + (b + "[" + d + "] = " + e + "\n");
                if ("INSERT" == c) return a + (b + ".insert(" + d + ", " + e + ")\n");
        }
        throw Error("Unhandled combination (lists_setIndex).");
    };
    Blockly.Python.lists_getSublist = function (a) {
        var b = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_MEMBER) || "[]",
            c = a.getFieldValue("WHERE1"),
            d = a.getFieldValue("WHERE2");
        switch (c) {
            case "FROM_START":
                c = Blockly.Python.getAdjustedInt(a, "AT1");
                "0" == c && (c = "");
                break;
            case "FROM_END":
                c = Blockly.Python.getAdjustedInt(a, "AT1", 1, !0);
                break;
            case "FIRST":
                c = "";
                break;
            default:
                throw Error("Unhandled option (lists_getSublist)");
        }
        switch (d) {
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 1);
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 0, !0);
                Blockly.isNumber(String(a)) ? "0" == a && (a = "") : ((Blockly.Python.definitions_.import_sys = "import sys"), (a += " or sys.maxsize"));
                break;
            case "LAST":
                a = "";
                break;
            default:
                throw Error("Unhandled option (lists_getSublist)");
        }
        return [b + "[" + c + " : " + a + "]", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.lists_sort = function (a) {
        var b = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_NONE) || "[]",
            c = a.getFieldValue("TYPE");
        a = "1" === a.getFieldValue("DIRECTION") ? "False" : "True";
        return [
            Blockly.Python.provideFunction_("lists_sort", [
                "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(my_list, type, reverse):",
                "  def try_float(s):",
                "    try:",
                "      return float(s)",
                "    except:",
                "      return 0",
                "  key_funcs = {",
                '    "NUMERIC": try_float,',
                '    "TEXT": str,',
                '    "IGNORE_CASE": lambda s: str(s).lower()',
                "  }",
                "  key_func = key_funcs[type]",
                "  list_cpy = list(my_list)",
                "  return sorted(list_cpy, key=key_func, reverse=reverse)",
            ]) +
            "(" +
            b +
            ', "' +
            c +
            '", ' +
            a +
            ")",
            Blockly.Python.ORDER_FUNCTION_CALL,
        ];
    };
   /*
    Blockly.Python.hello_test = function (a) {
        return ["OPTION1" == a.getFieldValue("NAME") ? "print('Hesham')" : "print('Hazem')", Blockly.Python.ORDER_ATOMIC];
    };
    */
    Blockly.Python.hello = function(block) {
        var dropdown_name = block.getFieldValue('NAME');
        if (dropdown_name == 'OPTION1') {
          var code = 'print("Hesham")';
        } else if (dropdown_name == 'OPTION2') {
          var code = 'print("Hazem")';
        } else {
          var code = 'print("Abzo")';
        }
        return [code, Blockly.Python.ORDER_FUNCTION_CALL];
      };

    Blockly.Python.lists_split = function (a) {
        var b = a.getFieldValue("MODE");
        if ("SPLIT" == b) (b = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_MEMBER) || "''"), (a = Blockly.Python.valueToCode(a, "DELIM", Blockly.Python.ORDER_NONE)), (a = b + ".split(" + a + ")");
        else if ("JOIN" == b) (b = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_NONE) || "[]"), (a = Blockly.Python.valueToCode(a, "DELIM", Blockly.Python.ORDER_MEMBER) || "''"), (a = a + ".join(" + b + ")");
        else throw Error("Unknown mode: " + b);
        return [a, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.lists_reverse = function (a) {
        return ["list(reversed(" + (Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_NONE) || "[]") + "))", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.logic = {};
    Blockly.Python.controls_if = function (a) {
        var b = 0,
            c = "";
        Blockly.Python.STATEMENT_PREFIX && (c += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, a));
        do {
            var d = Blockly.Python.valueToCode(a, "IF" + b, Blockly.Python.ORDER_NONE) || "False";
            var e = Blockly.Python.statementToCode(a, "DO" + b) || Blockly.Python.PASS;
            Blockly.Python.STATEMENT_SUFFIX && (e = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT) + e);
            c += (0 == b ? "if " : "elif ") + d + ":\n" + e;
            ++b;
        } while (a.getInput("IF" + b));
        if (a.getInput("ELSE") || Blockly.Python.STATEMENT_SUFFIX)
            (e = Blockly.Python.statementToCode(a, "ELSE") || Blockly.Python.PASS),
                Blockly.Python.STATEMENT_SUFFIX && (e = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT) + e),
                (c += "else:\n" + e);
        return c;
    };
    Blockly.Python.controls_ifelse = Blockly.Python.controls_if;
    Blockly.Python.logic_compare = function (a) {
        var b = { EQ: "==", NEQ: "!=", LT: "<", LTE: "<=", GT: ">", GTE: ">=" }[a.getFieldValue("OP")],
            c = Blockly.Python.ORDER_RELATIONAL,
            d = Blockly.Python.valueToCode(a, "A", c) || "0";
        a = Blockly.Python.valueToCode(a, "B", c) || "0";
        return [d + " " + b + " " + a, c];
    };
    Blockly.Python.logic_operation = function (a) {
        var b = "AND" == a.getFieldValue("OP") ? "and" : "or",
            c = "and" == b ? Blockly.Python.ORDER_LOGICAL_AND : Blockly.Python.ORDER_LOGICAL_OR,
            d = Blockly.Python.valueToCode(a, "A", c);
        a = Blockly.Python.valueToCode(a, "B", c);
        if (d || a) {
            var e = "and" == b ? "True" : "False";
            d || (d = e);
            a || (a = e);
        } else a = d = "False";
        return [d + " " + b + " " + a, c];
    };
    Blockly.Python.logic_negate = function (a) {
        return ["not " + (Blockly.Python.valueToCode(a, "BOOL", Blockly.Python.ORDER_LOGICAL_NOT) || "True"), Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.logic_boolean = function (a) {
        return ["TRUE" == a.getFieldValue("BOOL") ? "True" : "False", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.logic_null = function (a) {
        return ["None", Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.logic_ternary = function (a) {
        var b = Blockly.Python.valueToCode(a, "IF", Blockly.Python.ORDER_CONDITIONAL) || "False",
            c = Blockly.Python.valueToCode(a, "THEN", Blockly.Python.ORDER_CONDITIONAL) || "None";
        a = Blockly.Python.valueToCode(a, "ELSE", Blockly.Python.ORDER_CONDITIONAL) || "None";
        return [c + " if " + b + " else " + a, Blockly.Python.ORDER_CONDITIONAL];
    };
    Blockly.Python.loops = {};
    Blockly.Python.controls_repeat_ext = function (a) {
        var b = a.getField("TIMES") ? String(parseInt(a.getFieldValue("TIMES"), 10)) : Blockly.Python.valueToCode(a, "TIMES", Blockly.Python.ORDER_NONE) || "0";
        b = Blockly.isNumber(b) ? parseInt(b, 10) : "int(" + b + ")";
        var c = Blockly.Python.statementToCode(a, "DO");
        c = Blockly.Python.addLoopTrap(c, a) || Blockly.Python.PASS;
        return "for " + Blockly.Python.variableDB_.getDistinctName("count", Blockly.VARIABLE_CATEGORY_NAME) + " in range(" + b + "):\n" + c;
    };
    Blockly.Python.controls_repeat = Blockly.Python.controls_repeat_ext;
    Blockly.Python.controls_whileUntil = function (a) {
        var b = "UNTIL" == a.getFieldValue("MODE"),
            c = Blockly.Python.valueToCode(a, "BOOL", b ? Blockly.Python.ORDER_LOGICAL_NOT : Blockly.Python.ORDER_NONE) || "False",
            d = Blockly.Python.statementToCode(a, "DO");
        d = Blockly.Python.addLoopTrap(d, a) || Blockly.Python.PASS;
        b && (c = "not " + c);
        return "while " + c + ":\n" + d;
    };
    Blockly.Python.controls_for = function (a) {
        var b = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
            c = Blockly.Python.valueToCode(a, "FROM", Blockly.Python.ORDER_NONE) || "0",
            d = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "0",
            e = Blockly.Python.valueToCode(a, "BY", Blockly.Python.ORDER_NONE) || "1",
            f = Blockly.Python.statementToCode(a, "DO");
        f = Blockly.Python.addLoopTrap(f, a) || Blockly.Python.PASS;
        var n = "",
            k = function () {
                return Blockly.Python.provideFunction_("upRange", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start <= stop:", "    yield start", "    start += abs(step)"]);
            },
            h = function () {
                return Blockly.Python.provideFunction_("downRange", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(start, stop, step):", "  while start >= stop:", "    yield start", "    start -= abs(step)"]);
            };
        a = function (g, l, p) {
            return "(" + g + " <= " + l + ") and " + k() + "(" + g + ", " + l + ", " + p + ") or " + h() + "(" + g + ", " + l + ", " + p + ")";
        };
        if (Blockly.isNumber(c) && Blockly.isNumber(d) && Blockly.isNumber(e))
            (c = Number(c)),
                (d = Number(d)),
                (e = Math.abs(Number(e))),
                0 === c % 1 && 0 === d % 1 && 0 === e % 1
                    ? (c <= d ? (d++, (a = 0 == c && 1 == e ? d : c + ", " + d), 1 != e && (a += ", " + e)) : (d--, (a = c + ", " + d + ", -" + e)), (a = "range(" + a + ")"))
                    : ((a = c < d ? k() : h()), (a += "(" + c + ", " + d + ", " + e + ")"));
        else {
            var m = function (g, l) {
                Blockly.isNumber(g) ? (g = Number(g)) : g.match(/^\w+$/) ? (g = "float(" + g + ")") : ((l = Blockly.Python.variableDB_.getDistinctName(b + l, Blockly.VARIABLE_CATEGORY_NAME)), (n += l + " = float(" + g + ")\n"), (g = l));
                return g;
            };
            c = m(c, "_start");
            d = m(d, "_end");
            e = m(e, "_inc");
            "number" == typeof c && "number" == typeof d ? ((a = c < d ? k() : h()), (a += "(" + c + ", " + d + ", " + e + ")")) : (a = a(c, d, e));
        }
        return (n += "for " + b + " in " + a + ":\n" + f);
    };
    Blockly.Python.controls_forEach = function (a) {
        var b = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME),
            c = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_RELATIONAL) || "[]",
            d = Blockly.Python.statementToCode(a, "DO");
        d = Blockly.Python.addLoopTrap(d, a) || Blockly.Python.PASS;
        return "for " + b + " in " + c + ":\n" + d;
    };
    Blockly.Python.controls_flow_statements = function (a) {
        var b = "";
        Blockly.Python.STATEMENT_PREFIX && (b += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, a));
        Blockly.Python.STATEMENT_SUFFIX && (b += Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a));
        if (Blockly.Python.STATEMENT_PREFIX) {
            var c = Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(a);
            c && !c.suppressPrefixSuffix && (b += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, c));
        }
        switch (a.getFieldValue("FLOW")) {
            case "BREAK":
                return b + "break\n";
            case "CONTINUE":
                return b + "continue\n";
        }
        throw Error("Unknown flow statement.");
    };
    /*
     * Custom 
     */
    Blockly.Python.pandas = {};
    Blockly.Python['pandas_read_csv'] = function (a) {
        Blockly.Python.definitions_.pandas = "import pandas as pd";
        return ['pd.read_csv(' + String(a).split(" ")[2] + ')', Blockly.Python.ORDER_FUNCTION_CALL]
    }

    Blockly.Python["create_dict"] = function (a) {

        var b = 1,
            c = "{";
        do {
            var d = Blockly.Python.valueToCode(a, "KEY" + b, Blockly.Python.ORDER_NONE) || "";
            var e = Blockly.Python.valueToCode(a, "VAL" + b, Blockly.Python.ORDER_NONE) || "";
            Blockly.Python.STATEMENT_SUFFIX && (e = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT) + e);
            if (b > 1) {
                c += ",";
            }
            c += d + ":" + e;
            ++b;
        } while (a.getInput("KEY" + b));
        c += "}";
        if ((e != "") && (d != "")) {
            return [c, Blockly.Python.ORDER_FUNCTION_CALL];
        } else {
            return ["None", Blockly.Python.ORDER_FUNCTION_CALL];
        }
    }
    Blockly.Python["dict_append"] = function (a) {
        var e = ""
        var b = Blockly.Python.valueToCode(a, "DICTIONARY", Blockly.Python.ORDER_NONE) || "";
        var c = Blockly.Python.valueToCode(a, "KEY", Blockly.Python.ORDER_NONE) || "";
        var d = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "";
        if ((b != "") && (c != "") && (d != "")) {
            e = b + "[" + c + "] = " + d;
        }
        return e;
    }

    Blockly.Python['seaborn_dataset'] = function (a) {
        Blockly.Python.definitions_.seaborn = "import seaborn as sns";
        VarData[a.inputList[0].fieldRow[1].value_] = 'sns.load_dataset("' + a.inputList[0].fieldRow[1].value_ + '")', Blockly.Python.ORDER_FUNCTION_CALL;
        return ['sns.load_dataset("' + a.inputList[0].fieldRow[1].value_ + '")', Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['skl_train_test_split'] = function (a) {
        Blockly.Python.definitions_.sklearn_test_train_split = "from sklearn.model_selection import train_test_split";
        var dataframe = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_NONE) || ""
        var train_X = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME)
        var train_Y = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR2"), Blockly.VARIABLE_CATEGORY_NAME)
        var test_X = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR1"), Blockly.VARIABLE_CATEGORY_NAME)
        var test_Y = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR3"), Blockly.VARIABLE_CATEGORY_NAME)
        var target = Blockly.Python.valueToCode(a, "TARGETVAR", Blockly.Python.ORDER_NONE)
        var TestSize = Blockly.Python.valueToCode(a, "TESTSIZE", Blockly.Python.ORDER_NONE)

        var codeString = '\n' + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + '=train_test_split(' + dataframe + '.drop(columns = [' + target + ']),' + dataframe + '[' + target + ']' + ', test_size=' + TestSize + ', random_state=42)\n'
        var codeString2 = ""
        if (a.getFieldValue("SPLIT") == "dropNa") {
            codeString2 = 'def dropNa(' + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + '):\n' +
                '     ' + train_X + ' = ' + train_X + '.dropna()\n' +
                '     ' + train_Y + " = " + train_Y + ".loc[" + train_X + ".index.values.tolist()]\n" +
                '     ' + test_X + " = " + test_X + ".dropna()\n" +
                '     ' + test_Y + " = " + test_Y + ".loc[" + test_X + ".index.values.tolist()]\n" +
                '     return ' + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + '\n' +
                train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + " = " + "dropNa(" + train_X + ', ' + test_X + ', ' + train_Y + ', ' + test_Y + ")\n"

        }


        Blockly.Python.definitions_.pandas = "import pandas as pd";
        Blockly.Python.definitions_.encoder = "from sklearn.preprocessing import LabelEncoder, OneHotEncoder";
        Blockly.Python.definitions_.numpy = "import numpy as np"

        if (dataframe == "") {
            return ""
        }
        else {
            return codeString + codeString2
        }
    }


    Blockly.Python['pandas_drop_columns'] = function (a) {
        var columns = Blockly.Python.valueToCode(a, "COLUMN", Blockly.Python.ORDER_UNARY_SIGN)
        if (columns == "") {
            return ""
        }
        var DataFrame = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_UNARY_SIGN)
        if (a.getInputTargetBlock("COLUMN").outputConnection.getCheck() == "String") {
            return [DataFrame + ".drop([" + columns + "], axis = 1)", Blockly.Python.ORDER_ATOMIC];
        } if (a.getInputTargetBlock("COLUMN").outputConnection.getCheck() == "Array") {
            return [DataFrame + ".drop([" + columns + "], axis = 1)", Blockly.Python.ORDER_ATOMIC];
        } if (columns == "" || DataFrame == "") {
            return ["", Blockly.Python.ORDER_ATOMIC];
        }
    }

    Blockly.Python['pandas_sample'] = function (a) {
        var factor = Blockly.Python.valueToCode(a, "FACTOR", Blockly.Python.ORDER_UNARY_SIGN)
        if (factor == "") {
            return ""
        }
        var DataFrame = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_UNARY_SIGN)
        if (factor != "" || DataFrame != "") {
            return [DataFrame + ".sample(frac=" + factor + ", replace=True, random_state=123)", Blockly.Python.ORDER_ATOMIC];
        }
    }


    Blockly.Python['pandas_select_columns'] = function (a) {
        var columns = Blockly.Python.valueToCode(a, "COLUMN", Blockly.Python.ORDER_UNARY_SIGN)
        if (columns == "") {
            columns = "[]"
        }
        var DataFrame = Blockly.Python.valueToCode(a, "DATAFRAME", Blockly.Python.ORDER_UNARY_SIGN)
        return [DataFrame + "[" + columns + "]", Blockly.Python.ORDER_ATOMIC];
    }

    Blockly.Python['Classification_Report'] = function (a) {
        Blockly.Python.definitions_.classification_report = "from sklearn.metrics import classification_report";
        var Pred = Blockly.Python.valueToCode(a, "Pred", Blockly.Python.ORDER_UNARY_SIGN) || "";
        var True = Blockly.Python.valueToCode(a, "True", Blockly.Python.ORDER_UNARY_SIGN) || "";
        if ((Pred != "") && (True != "")) {
            return ["classification_report(" + True + ", " + Pred + ")", Blockly.Python.ORDER_FUNCTION_CALL];
        } else {
            return ["", Blockly.Python.ORDER_FUNCTION_CALL];
        }

    }
    Blockly.Python['R2_Report'] = function (a) {
        Blockly.Python.definitions_.r2_score = "from sklearn.metrics import r2_score";
        var Pred = Blockly.Python.valueToCode(a, "Pred", Blockly.Python.ORDER_UNARY_SIGN)
        var True = Blockly.Python.valueToCode(a, "True", Blockly.Python.ORDER_UNARY_SIGN)
        if ((Pred != "") && (True != "")) {
            return ["r2_score(" + True + ", " + Pred + ")", Blockly.Python.ORDER_FUNCTION_CALL];
        } else {
            return ["", Blockly.Python.ORDER_FUNCTION_CALL];
        }
    }
    Blockly.Python['Print'] = function (a) {
        var INPUT = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_FUNCTION_CALL) || "''";
        var End = a.getFieldValue("END")

        if (End == "newLine") {
            return "print(" + INPUT + ")" + "\n";
        }
        if (End == "tab") {
            return "print(" + INPUT + ",end='\\t')" + "\n";
        }
        if (End == "space") {
            return "print(" + INPUT + ",end=' ')" + "\n";
        }
        if (End == "comma") {
            return "print(" + INPUT + ",end=',')" + "\n";
        }
    }

    Blockly.Python['pycaret_setup'] = function (a) {
        var input_data = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        var input_column = Blockly.Python.valueToCode(a, "input_column", Blockly.Python.ORDER_NONE) || "";
        var algorithm = a.getFieldValue("algorithm");

        if (input_data == "") {
            return ""
        }
        if (algorithm == "Classification") {
            Blockly.Python.definitions_.pycaret_classification = "from pycaret.classification import *";
        }
        if (algorithm == "Regression") {
            Blockly.Python.definitions_.pycaret_regression = "from pycaret.regression import *";
        }
        return "setup(" + input_data + ", target = " + input_column + ")" + "\n";


    }
    Blockly.Python['pycaret_predict'] = function (a) {
        var input_model = Blockly.Python.valueToCode(a, "input_model", Blockly.Python.ORDER_NONE) || "";
        var input_data = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        console.log(input_model)
        if (input_model == "") {
            return ["", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_model != "" && input_data == "") {
            return ["predict_model(" + input_model + ")", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_model != "" && input_data != "") {
            return ["predict_model(" + input_model + ", data=" + input_data + ")", Blockly.Python.ORDER_FUNCTION_CALL]
        }
    }
    Blockly.Python['pycaret_save'] = function (a) {

        var input_model = Blockly.Python.valueToCode(a, "input_model", Blockly.Python.ORDER_NONE) || "";
        var input_data = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        if (input_model != "" || input_data != "") {
            return "save_model(" + input_model + "," + input_data + ")" + "\n";
        }
        else {
            return ""
        }
    }

    Blockly.Python['pycaret_plot_model'] = function (a) {

        var input_model = Blockly.Python.valueToCode(a, "input_model", Blockly.Python.ORDER_NONE) || "";
        var plot_data = a.getFieldValue("plot_data");
        if (input_model != "" || plot_data != "") {
            return "plot_model(" + input_model + ", plot = '" + plot_data + "')" + "\n";
        }
        else {
            return ""
        }
    }

    Blockly.Python['pycaret_blend_model'] = function (a) {
        var input_models = Blockly.Python.valueToCode(a, "input_models", Blockly.Python.ORDER_NONE) || "";
        var input_fold = Blockly.Python.valueToCode(a, "input_fold", Blockly.Python.ORDER_NONE) || "";
        var input_method = a.getFieldValue("input_method");
        if (input_models != "" && input_fold == "") {
            return ["blend_models(" + input_models + ", method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_models != "" && input_fold != "") {
            return ["blend_models(" + input_models + " , fold = '" + input_fold + "' , method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        else {
            return ""
        }
    }

    Blockly.Python['pycaret_ensemble_model'] = function (a) {
        var input_models = Blockly.Python.valueToCode(a, "input_models", Blockly.Python.ORDER_NONE) || "";
        var input_fold = Blockly.Python.valueToCode(a, "input_fold", Blockly.Python.ORDER_NONE) || "";
        var input_method = a.getFieldValue("input_method");
        if (input_models != "" && input_fold == "") {
            return ["ensemble_model(" + input_models + ", method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        if (input_models != "" && input_fold != "") {
            return ["ensemble_model(" + input_models + " , fold = '" + input_fold + "' , method = '" + input_method + "')", Blockly.Python.ORDER_FUNCTION_CALL]
        }
        else {
            return ""
        }
    }
    Blockly.Python['pycaret_load'] = function (a) {
        var input_model = Blockly.Python.valueToCode(a, "input_data", Blockly.Python.ORDER_NONE) || "";
        if (input_model != "") {
            return ["load_model(" + input_model + ")", Blockly.Python.ORDER_FUNCTION_CALL]

        }
        else {
            return ""
        }
    }
    Blockly.Python['pycaret_automl'] = function (a) {
        var optimizer = a.getFieldValue("optimizer");
        return ["automl(optimize = '" + optimizer + "')", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['pycaret_classifier'] = function (a) {
        var model = a.getFieldValue("model");
        return ["create_model('" + model + "')", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['pycaret_regressor'] = function (a) {
        var model = a.getFieldValue("model");
        return ["create_model('" + model + "')", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['Input'] = function (a) {
        var INPUT = Blockly.Python.valueToCode(a, "INPUT", Blockly.Python.ORDER_NONE) || "''";
        return ["input(" + INPUT + ")", Blockly.Python.ORDER_FUNCTION_CALL]
    }
    Blockly.Python['pandas_set_columns'] = function (a) {
        var columns = Blockly.Python.valueToCode(a, "COLUMN", Blockly.Python.ORDER_UNARY_SIGN)
        if (columns == "") {
            columns = "[]"
        }
        var DATAFRAME_IN = Blockly.Python.valueToCode(a, "DATAFRAME_IN", Blockly.Python.ORDER_UNARY_SIGN)
        var DATAFRAME_OUT = Blockly.Python.valueToCode(a, "DATAFRAME_OUT", Blockly.Python.ORDER_UNARY_SIGN)
        if (DATAFRAME_IN != "" || DATAFRAME_OUT != "" || columns != "") {
            return DATAFRAME_OUT + "[" + columns + "]=" + DATAFRAME_IN + "\n";
        }
        else {
            return ""
        }
    }




    Blockly.Python['dataframe_Filter'] = function (a) {
        var b = { EQ: "==", NEQ: "!=", LT: "<", LTE: "<=", GT: ">", GTE: ">=" }[a.getFieldValue("OP")];
        var c = Blockly.Python.ORDER_RELATIONAL;
        var d = Blockly.Python.valueToCode(a, "A", c) || "";
        var e = Blockly.Python.valueToCode(a, "C", c) || "";
        a = Blockly.Python.valueToCode(a, "B", c) || "";
        if (d == "" || e == "" || a == "") {
            return ["", Blockly.Python.ORDER_NONE]
        }

        return [e + "[" + d + " " + b + " " + a + "]", Blockly.Python.ORDER_FUNCTION_CALL];
    };


    Blockly.Python['dataframe_Map'] = function (a) {
        var c = Blockly.Python.ORDER_NONE;
        var b = Blockly.Python.valueToCode(a, "Map", c) || "";
        var d = Blockly.Python.valueToCode(a, "Series", c) || "";
        if (b == "" || d == "") {
            return ["", Blockly.Python.ORDER_NONE]
        }

        return [d + ".map(" + b + ")", Blockly.Python.ORDER_ATOMIC];
    };


    Blockly.Python['CLR_XGBoost'] = function (a) {
        Blockly.Python.definitions_.XGBClassifier = "from xgboost import XGBClassifier";
        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "XGBClassifier(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + ")"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "XGBClassifier()"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['REG_LinearRegression'] = function (a) {
        Blockly.Python.definitions_.LinearRegression = "from sklearn.linear_model import LinearRegression";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("REG_LinearRegression", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "Pipeline([('encoding', HandleCatagoricalData('labelEncoding')), ('scaler', StandardScaler()), ('LR', LinearRegression(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("LR", LinearRegression())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['REG_XGBRegressor'] = function (a) {
        Blockly.Python.definitions_.XGBRegressor = "from xgboost import XGBRegressor";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("REG_XGBRegressor", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])


        var codeString = ""
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "Pipeline([('encoding', HandleCatagoricalData('labelEncoding')), ('scaler', StandardScaler()), ('XGB', XGBRegressor(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("XGB", XGBRegressor())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['NN_Regression'] = function (a) {
        Blockly.Python.definitions_.XGBRegressor = "from xgboost import XGBRegressor";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("NN_Regression", [
        '    import tensorflow as tf\n'+
        '    from tensorflow.keras.models import Sequential\n'+
        '    from tensorflow.keras.layers import Dense\n'+
        '    model = Sequential()\n'+
        '    model.add(Dense(64, input_dim=${features.length}, activation="relu"))\n'+
        '    model.add(Dense(1, activation="linear"))\n'+
        '    model.compile(optimizer="adam", loss="mean_squared_error")\n'+
        '    model.fit(${features}, ${labels}, epochs=100, batch_size=32)\n'+
        '    return X\n'
        ])


        var codeString = ""
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += "Pipeline([('encoding', HandleCatagoricalData('labelEncoding')), ('scaler', StandardScaler()), ('XGB', XGBRegressor(**" + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("XGB", XGBRegressor())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE)
                + ", eval_set = [(" + Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }

    Blockly.Python['CLR_LogisticRegression'] = function (a) {
        Blockly.Python.definitions_.LogisticRegression = "from sklearn.linear_model import LogisticRegression";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_LogisticRegression", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])
        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("LR",LogisticRegression(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + '))])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("LR", LogisticRegression())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return ([codeString, Blockly.Python.ORDER_FUNCTION_CALL])

    }


    Blockly.Python['CLR_NaiveBayes'] = function (a) {
        Blockly.Python.definitions_.GaussianNB = "from sklearn.naive_bayes import GaussianNB";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_NaiveBayes", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("GNB",GaussianNB())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("GNB",GaussianNB(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }
    Blockly.Python['CLR_KNN'] = function (a) {
        Blockly.Python.definitions_.KNeighborsClassifier = "from sklearn.neighbors import KNeighborsClassifier";


        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_KNN", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("KNN",KNeighborsClassifier())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("KNN",KNeighborsClassifier(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }
    Blockly.Python['CLR_DecisionTree'] = function (a) {
        Blockly.Python.definitions_.tree = "from sklearn import tree";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_DecisionTree", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])


        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("Dtree",tree.DecisionTreeClassifier(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + "))])"
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("Dtree",tree.DecisionTreeClassifier())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }
    Blockly.Python['CLR_SVM'] = function (a) {
        Blockly.Python.definitions_.SVC = "from sklearn.svm import SVC";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_SVM", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("SVC", SVC(gamma="auto"))])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"

        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("SVC", SVC(gamma="auto"))])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }
        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }

    Blockly.Python['CLR_RandomForest'] = function (a) {
        Blockly.Python.definitions_.RandomForestClassifier = "from sklearn.ensemble import RandomForestClassifier";

        var HandleCatagoricalData = Blockly.Python.provideFunction_("CLR_RandomForest", [
            'class HandleCatagoricalData():\n' +
            '   def __init__(self,method="labelEncoding",factor=0):\n' +
            '       self.method = method\n' +
            '       self.factor = factor\n' +
            '   def fit(self, X, y):\n' +
            '       if self.method == "labelEncoding":\n' +
            '         X = pd.DataFrame(data=X)\n' +
            '         y = pd.DataFrame(data=y)\n' +
            '         self.LE = LabelEncoder()\n' +
            '         for column in X:\n' +
            '           if X[column].dtype == np.object:\n' +
            '             X[column]=X[column].astype("category")\n' +
            '           if X[column].dtype.name == "category":\n' +
            '             X[column] = self.LE.fit_transform(X[column])\n' +
            '         X = X.to_numpy()\n' +
            '         y = y.to_numpy()\n' +
            '         return self\n' +
            '   def transform(self, X):\n' +
            '       X = pd.DataFrame(data=X)\n' +
            '       for column in X:\n' +
            '         if X[column].dtype == np.object:\n' +
            '           X[column]=X[column].astype("category")\n' +
            '         if X[column].dtype.name == "category":\n' +
            '           X[column] = self.LE.fit_transform(X[column])\n' +
            '       X = X.to_numpy()\n' +
            '       return X\n'
        ])

        var codeString = ""

        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("RFC", RandomForestClassifier())])'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += 'Pipeline([("encoding", HandleCatagoricalData("labelEncoding")), ("scaler", StandardScaler()), ("RFC", RandomForestClassifier(**' + Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) + ')'
            Blockly.Python.definitions_.pipeline = "from sklearn.pipeline import Pipeline"
            Blockly.Python.definitions_.StandardScaler = "from sklearn.preprocessing import StandardScaler"
        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ")"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) != "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) + ".fit(" + Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE)
                + "," + Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) + ") # Eval TBD"


        }
        if (Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) != "" &&
            Blockly.Python.valueToCode(a, "PARAMS", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YTRAIN", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "XVALID", Blockly.Python.ORDER_NONE) == "" &&
            Blockly.Python.valueToCode(a, "YVALID", Blockly.Python.ORDER_NONE) == "") {
            codeString += Blockly.Python.valueToCode(a, "TMODEL", Blockly.Python.ORDER_NONE)
                + ".predict("
                + Blockly.Python.valueToCode(a, "XTEST", Blockly.Python.ORDER_NONE) + ")"


        }



        return [codeString, Blockly.Python.ORDER_FUNCTION_CALL]

    }

    Blockly.Python.math = {};
    Blockly.Python.addReservedWords("math,random,Number");
    Blockly.Python.math_number = function (a) {
        a = Number(a.getFieldValue("NUM"));

        if (Infinity == a) {
            a = 'float("inf")';
            var b = Blockly.Python.ORDER_FUNCTION_CALL;
        } else -Infinity == a ? ((a = '-float("inf")'), (b = Blockly.Python.ORDER_UNARY_SIGN)) : (b = 0 > a ? Blockly.Python.ORDER_UNARY_SIGN : Blockly.Python.ORDER_ATOMIC);
        return [a, b];
    };
    Blockly.Python.math_arithmetic = function (a) {
        var b = {
            ADD: [" + ", Blockly.Python.ORDER_ADDITIVE],
            MINUS: [" - ", Blockly.Python.ORDER_ADDITIVE],
            MULTIPLY: [" * ", Blockly.Python.ORDER_MULTIPLICATIVE],
            DIVIDE: [" / ", Blockly.Python.ORDER_MULTIPLICATIVE],
            POWER: [" ** ", Blockly.Python.ORDER_EXPONENTIATION],
        }[a.getFieldValue("OP")],
            c = b[0];
        b = b[1];
        var d = Blockly.Python.valueToCode(a, "A", b) || "0";
        a = Blockly.Python.valueToCode(a, "B", b) || "0";
        return [d + c + a, b];
    };
    Blockly.Python.math_single = function (a) {
        var b = a.getFieldValue("OP");
        if ("NEG" == b) {
            var c = Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_UNARY_SIGN) || "0";
            return ["-" + c, Blockly.Python.ORDER_UNARY_SIGN];
        }
        Blockly.Python.definitions_.import_math = "import math";
        a = "SIN" == b || "COS" == b || "TAN" == b ? Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_MULTIPLICATIVE) || "0" : Blockly.Python.valueToCode(a, "NUM", Blockly.Python.ORDER_NONE) || "0";
        switch (b) {
            case "ABS":
                c = "math.fabs(" + a + ")";
                break;
            case "ROOT":
                c = "math.sqrt(" + a + ")";
                break;
            case "LN":
                c = "math.log(" + a + ")";
                break;
            case "LOG10":
                c = "math.log10(" + a + ")";
                break;
            case "EXP":
                c = "math.exp(" + a + ")";
                break;
            case "POW10":
                c = "math.pow(10," + a + ")";
                break;
            case "ROUND":
                c = "round(" + a + ")";
                break;
            case "ROUNDUP":
                c = "math.ceil(" + a + ")";
                break;
            case "ROUNDDOWN":
                c = "math.floor(" + a + ")";
                break;
            case "SIN":
                c = "math.sin(" + a + " / 180.0 * math.pi)";
                break;
            case "COS":
                c = "math.cos(" + a + " / 180.0 * math.pi)";
                break;
            case "TAN":
                c = "math.tan(" + a + " / 180.0 * math.pi)";
        }
        if (c) return [c, Blockly.Python.ORDER_FUNCTION_CALL];
        switch (b) {
            case "ASIN":
                c = "math.asin(" + a + ") / math.pi * 180";
                break;
            case "ACOS":
                c = "math.acos(" + a + ") / math.pi * 180";
                break;
            case "ATAN":
                c = "math.atan(" + a + ") / math.pi * 180";
                break;
            default:
                throw Error("Unknown math operator: " + b);
        }
        return [c, Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.math_constant = function (a) {
        var b = {
            PI: ["math.pi", Blockly.Python.ORDER_MEMBER],
            E: ["math.e", Blockly.Python.ORDER_MEMBER],
            GOLDEN_RATIO: ["(1 + math.sqrt(5)) / 2", Blockly.Python.ORDER_MULTIPLICATIVE],
            SQRT2: ["math.sqrt(2)", Blockly.Python.ORDER_MEMBER],
            SQRT1_2: ["math.sqrt(1.0 / 2)", Blockly.Python.ORDER_MEMBER],
            INFINITY: ["float('inf')", Blockly.Python.ORDER_ATOMIC],
        };
        a = a.getFieldValue("CONSTANT");
        "INFINITY" != a && (Blockly.Python.definitions_.import_math = "import math");
        return b[a];
    };
    Blockly.Python.math_number_property = function (a) {
        var b = Blockly.Python.valueToCode(a, "NUMBER_TO_CHECK", Blockly.Python.ORDER_MULTIPLICATIVE) || "0",
            c = a.getFieldValue("PROPERTY");
        if ("PRIME" == c)
            return (
                (Blockly.Python.definitions_.import_math = "import math"),
                (Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number"),
                [
                    Blockly.Python.provideFunction_("math_isPrime", [
                        "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(n):",
                        "  # https://en.wikipedia.org/wiki/Primality_test#Naive_methods",
                        "  # If n is not a number but a string, try parsing it.",
                        "  if not isinstance(n, Number):",
                        "    try:",
                        "      n = float(n)",
                        "    except:",
                        "      return False",
                        "  if n == 2 or n == 3:",
                        "    return True",
                        "  # False if n is negative, is 1, or not whole, or if n is divisible by 2 or 3.",
                        "  if n <= 1 or n % 1 != 0 or n % 2 == 0 or n % 3 == 0:",
                        "    return False",
                        "  # Check all the numbers of form 6k +/- 1, up to sqrt(n).",
                        "  for x in range(6, int(math.sqrt(n)) + 2, 6):",
                        "    if n % (x - 1) == 0 or n % (x + 1) == 0:",
                        "      return False",
                        "  return True",
                    ]) +
                    "(" +
                    b +
                    ")",
                    Blockly.Python.ORDER_FUNCTION_CALL,
                ]
            );
        switch (c) {
            case "EVEN":
                var d = b + " % 2 == 0";
                break;
            case "ODD":
                d = b + " % 2 == 1";
                break;
            case "WHOLE":
                d = b + " % 1 == 0";
                break;
            case "POSITIVE":
                d = b + " > 0";
                break;
            case "NEGATIVE":
                d = b + " < 0";
                break;
            case "DIVISIBLE_BY":
                a = Blockly.Python.valueToCode(a, "DIVISOR", Blockly.Python.ORDER_MULTIPLICATIVE);
                if (!a || "0" == a) return ["False", Blockly.Python.ORDER_ATOMIC];
                d = b + " % " + a + " == 0";
        }
        return [d, Blockly.Python.ORDER_RELATIONAL];
    };
    Blockly.Python.math_change = function (a) {
        Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
        var b = Blockly.Python.valueToCode(a, "DELTA", Blockly.Python.ORDER_ADDITIVE) || "0";
        a = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
        return a + " = (" + a + " if isinstance(" + a + ", Number) else 0) + " + b + "\n";
    };
    Blockly.Python.math_round = Blockly.Python.math_single;
    Blockly.Python.math_trig = Blockly.Python.math_single;
    Blockly.Python.math_on_list = function (a) {
        var b = a.getFieldValue("OP");
        a = Blockly.Python.valueToCode(a, "LIST", Blockly.Python.ORDER_NONE) || "[]";
        switch (b) {
            case "SUM":
                b = "sum(" + a + ")";
                break;
            case "MIN":
                b = "min(" + a + ")";
                break;
            case "MAX":
                b = "max(" + a + ")";
                break;
            case "AVERAGE":
                Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
                b = Blockly.Python.provideFunction_("math_mean", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):",
                    "  localList = [e for e in myList if isinstance(e, Number)]",
                    "  if not localList: return",
                    "  return float(sum(localList)) / len(localList)",
                ]);
                b = b + "(" + a + ")";
                break;
            case "MEDIAN":
                Blockly.Python.definitions_.from_numbers_import_Number = "from numbers import Number";
                b = Blockly.Python.provideFunction_("math_median", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(myList):",
                    "  localList = sorted([e for e in myList if isinstance(e, Number)])",
                    "  if not localList: return",
                    "  if len(localList) % 2 == 0:",
                    "    return (localList[len(localList) // 2 - 1] + localList[len(localList) // 2]) / 2.0",
                    "  else:",
                    "    return localList[(len(localList) - 1) // 2]",
                ]);
                b = b + "(" + a + ")";
                break;
            case "MODE":
                b = Blockly.Python.provideFunction_("math_modes", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(some_list):",
                    "  modes = []",
                    "  # Using a lists of [item, count] to keep count rather than dict",
                    '  # to avoid "unhashable" errors when the counted item is itself a list or dict.',
                    "  counts = []",
                    "  maxCount = 1",
                    "  for item in some_list:",
                    "    found = False",
                    "    for count in counts:",
                    "      if count[0] == item:",
                    "        count[1] += 1",
                    "        maxCount = max(maxCount, count[1])",
                    "        found = True",
                    "    if not found:",
                    "      counts.append([item, 1])",
                    "  for counted_item, item_count in counts:",
                    "    if item_count == maxCount:",
                    "      modes.append(counted_item)",
                    "  return modes",
                ]);
                b = b + "(" + a + ")";
                break;
            case "STD_DEV":
                Blockly.Python.definitions_.import_math = "import math";
                b = Blockly.Python.provideFunction_("math_standard_deviation", [
                    "def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(numbers):",
                    "  n = len(numbers)",
                    "  if n == 0: return",
                    "  mean = float(sum(numbers)) / n",
                    "  variance = sum((x - mean) ** 2 for x in numbers) / n",
                    "  return math.sqrt(variance)",
                ]);
                b = b + "(" + a + ")";
                break;
            case "RANDOM":
                Blockly.Python.definitions_.import_random = "import random";
                b = "random.choice(" + a + ")";
                break;
            default:
                throw Error("Unknown operator: " + b);
        }
        return [b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_modulo = function (a) {
        var b = Blockly.Python.valueToCode(a, "DIVIDEND", Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        a = Blockly.Python.valueToCode(a, "DIVISOR", Blockly.Python.ORDER_MULTIPLICATIVE) || "0";
        return [b + " % " + a, Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.math_constrain = function (a) {
        var b = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "0",
            c = Blockly.Python.valueToCode(a, "LOW", Blockly.Python.ORDER_NONE) || "0";
        a = Blockly.Python.valueToCode(a, "HIGH", Blockly.Python.ORDER_NONE) || "float('inf')";
        return ["min(max(" + b + ", " + c + "), " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_random_int = function (a) {
        Blockly.Python.definitions_.import_random = "import random";
        var b = Blockly.Python.valueToCode(a, "FROM", Blockly.Python.ORDER_NONE) || "0";
        a = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "0";
        return ["random.randint(" + b + ", " + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_random_float = function (a) {
        Blockly.Python.definitions_.import_random = "import random";
        return ["random.random()", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.math_atan2 = function (a) {
        Blockly.Python.definitions_.import_math = "import math";
        var b = Blockly.Python.valueToCode(a, "X", Blockly.Python.ORDER_NONE) || "0";
        return ["math.atan2(" + (Blockly.Python.valueToCode(a, "Y", Blockly.Python.ORDER_NONE) || "0") + ", " + b + ") / math.pi * 180", Blockly.Python.ORDER_MULTIPLICATIVE];
    };
    Blockly.Python.procedures = {};
    Blockly.Python.procedures_defreturn = function (a) {
        for (var b = [], c, d = a.workspace, e = Blockly.Variables.allUsedVarModels(d) || [], f = 0; (c = e[f]); f++)
            (c = c.name), -1 == a.getVars().indexOf(c) && b.push(Blockly.Python.variableDB_.getName(c, Blockly.VARIABLE_CATEGORY_NAME));
        e = Blockly.Variables.allDeveloperVariables(d);
        for (f = 0; f < e.length; f++) b.push(Blockly.Python.variableDB_.getName(e[f], Blockly.Names.DEVELOPER_VARIABLE_TYPE));
        b = b.length ? Blockly.Python.INDENT + "global " + b.join(", ") + "\n" : "";
        d = Blockly.Python.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME);
        c = "";
        Blockly.Python.STATEMENT_PREFIX && (c += Blockly.Python.injectId(Blockly.Python.STATEMENT_PREFIX, a));
        Blockly.Python.STATEMENT_SUFFIX && (c += Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a));
        c && (c = Blockly.Python.prefixLines(c, Blockly.Python.INDENT));
        var n = "";
        Blockly.Python.INFINITE_LOOP_TRAP && (n = Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.INFINITE_LOOP_TRAP, a), Blockly.Python.INDENT));
        var k = Blockly.Python.statementToCode(a, "STACK"),
            h = Blockly.Python.valueToCode(a, "RETURN", Blockly.Python.ORDER_NONE) || "",
            m = "";
        k && h && (m = c);
        h ? (h = Blockly.Python.INDENT + "return " + h + "\n") : k || (k = Blockly.Python.PASS);
        var g = [];
        e = a.getVars();
        for (f = 0; f < e.length; f++) g[f] = Blockly.Python.variableDB_.getName(e[f], Blockly.VARIABLE_CATEGORY_NAME);
        b = "def " + d + "(" + g.join(", ") + "):\n" + b + c + n + k + m + h;
        b = Blockly.Python.scrub_(a, b);
        Blockly.Python.definitions_["%" + d] = b;
        return null;
    };
    Blockly.Python.procedures_defnoreturn = Blockly.Python.procedures_defreturn;
    Blockly.Python.procedures_callreturn = function (a) {
        for (var b = Blockly.Python.variableDB_.getName(a.getFieldValue("NAME"), Blockly.PROCEDURE_CATEGORY_NAME), c = [], d = a.getVars(), e = 0; e < d.length; e++)
            c[e] = Blockly.Python.valueToCode(a, "ARG" + e, Blockly.Python.ORDER_NONE) || "None";
        return [b + "(" + c.join(", ") + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.procedures_callnoreturn = function (a) {
        return Blockly.Python.procedures_callreturn(a)[0] + "\n";
    };
    Blockly.Python.procedures_ifreturn = function (a) {
        var b = "if " + (Blockly.Python.valueToCode(a, "CONDITION", Blockly.Python.ORDER_NONE) || "False") + ":\n";
        Blockly.Python.STATEMENT_SUFFIX && (b += Blockly.Python.prefixLines(Blockly.Python.injectId(Blockly.Python.STATEMENT_SUFFIX, a), Blockly.Python.INDENT));
        a.hasReturnValue_ ? ((a = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "None"), (b += Blockly.Python.INDENT + "return " + a + "\n")) : (b += Blockly.Python.INDENT + "return\n");
        return b;
    };
    Blockly.Python.texts = {};
    Blockly.Python.text = function (a) {
        return [Blockly.Python.quote_(a.getFieldValue("TEXT")), Blockly.Python.ORDER_ATOMIC];
    };
    Blockly.Python.text_multiline = function (a) {
        a = Blockly.Python.multiline_quote_(a.getFieldValue("TEXT"));
        var b = -1 != a.indexOf("+") ? Blockly.Python.ORDER_ADDITIVE : Blockly.Python.ORDER_ATOMIC;
        return [a, b];
    };
    Blockly.Python.text.forceString_ = function (a) {
        return Blockly.Python.text.forceString_.strRegExp.test(a) ? [a, Blockly.Python.ORDER_ATOMIC] : ["str(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text.forceString_.strRegExp = /^\s*'([^']|\\')*'\s*$/;
    Blockly.Python.text_join = function (a) {
        switch (a.itemCount_) {
            case 0:
                return ["''", Blockly.Python.ORDER_ATOMIC];
            case 1:
                return (a = Blockly.Python.valueToCode(a, "ADD0", Blockly.Python.ORDER_NONE) || "''"), Blockly.Python.text.forceString_(a);
            case 2:
                var b = Blockly.Python.valueToCode(a, "ADD0", Blockly.Python.ORDER_NONE) || "''";
                a = Blockly.Python.valueToCode(a, "ADD1", Blockly.Python.ORDER_NONE) || "''";
                a = Blockly.Python.text.forceString_(b)[0] + " + " + Blockly.Python.text.forceString_(a)[0];
                return [a, Blockly.Python.ORDER_ADDITIVE];
            default:
                b = [];
                for (var c = 0; c < a.itemCount_; c++) b[c] = Blockly.Python.valueToCode(a, "ADD" + c, Blockly.Python.ORDER_NONE) || "''";
                a = Blockly.Python.variableDB_.getDistinctName("x", Blockly.VARIABLE_CATEGORY_NAME);
                a = "''.join([str(" + a + ") for " + a + " in [" + b.join(", ") + "]])";
                return [a, Blockly.Python.ORDER_FUNCTION_CALL];
        }
    };
    Blockly.Python.text_append = function (a) {
        var b = Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME);
        a = Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_NONE) || "''";
        return b + " = str(" + b + ") + " + Blockly.Python.text.forceString_(a)[0] + "\n";
    };
    Blockly.Python.text_length = function (a) {
        return ["len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''") + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_isEmpty = function (a) {
        return ["not len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''") + ")", Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.text_isEmpty2 = function (a) {
        return ["not len(" + (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "''") + ")x", Blockly.Python.ORDER_LOGICAL_NOT];
    };
    Blockly.Python.text_indexOf = function (a) {
        var b = "FIRST" == a.getFieldValue("END") ? "find" : "rfind",
            c = Blockly.Python.valueToCode(a, "FIND", Blockly.Python.ORDER_NONE) || "''";
        b = (Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_MEMBER) || "''") + "." + b + "(" + c + ")";
        return a.workspace.options.oneBasedIndex ? [b + " + 1", Blockly.Python.ORDER_ADDITIVE] : [b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_charAt = function (a) {
        var b = a.getFieldValue("WHERE") || "FROM_START",
            c = Blockly.Python.valueToCode(a, "VALUE", "RANDOM" == b ? Blockly.Python.ORDER_NONE : Blockly.Python.ORDER_MEMBER) || "''";
        switch (b) {
            case "FIRST":
                return [c + "[0]", Blockly.Python.ORDER_MEMBER];
            case "LAST":
                return [c + "[-1]", Blockly.Python.ORDER_MEMBER];
            case "FROM_START":
                return (a = Blockly.Python.getAdjustedInt(a, "AT")), [c + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
            case "FROM_END":
                return (a = Blockly.Python.getAdjustedInt(a, "AT", 1, !0)), [c + "[" + a + "]", Blockly.Python.ORDER_MEMBER];
            case "RANDOM":
                return (
                    (Blockly.Python.definitions_.import_random = "import random"),
                    [
                        Blockly.Python.provideFunction_("text_random_letter", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(text):", "  x = int(random.random() * len(text))", "  return text[x];"]) + "(" + c + ")",
                        Blockly.Python.ORDER_FUNCTION_CALL,
                    ]
                );
        }
        throw Error("Unhandled option (text_charAt).");
    };
    Blockly.Python.text_getSubstring = function (a) {
        var b = a.getFieldValue("WHERE1"),
            c = a.getFieldValue("WHERE2"),
            d = Blockly.Python.valueToCode(a, "STRING", Blockly.Python.ORDER_MEMBER) || "''";
        switch (b) {
            case "FROM_START":
                b = Blockly.Python.getAdjustedInt(a, "AT1");
                "0" == b && (b = "");
                break;
            case "FROM_END":
                b = Blockly.Python.getAdjustedInt(a, "AT1", 1, !0);
                break;
            case "FIRST":
                b = "";
                break;
            default:
                throw Error("Unhandled option (text_getSubstring)");
        }
        switch (c) {
            case "FROM_START":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 1);
                break;
            case "FROM_END":
                a = Blockly.Python.getAdjustedInt(a, "AT2", 0, !0);
                Blockly.isNumber(String(a)) ? "0" == a && (a = "") : ((Blockly.Python.definitions_.import_sys = "import sys"), (a += " or sys.maxsize"));
                break;
            case "LAST":
                a = "";
                break;
            default:
                throw Error("Unhandled option (text_getSubstring)");
        }
        return [d + "[" + b + " : " + a + "]", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.text_changeCase = function (a) {
        var b = { UPPERCASE: ".upper()", LOWERCASE: ".lower()", TITLECASE: ".title()" }[a.getFieldValue("CASE")];
        return [(Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''") + b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_trim = function (a) {
        var b = { LEFT: ".lstrip()", RIGHT: ".rstrip()", BOTH: ".strip()" }[a.getFieldValue("MODE")];
        return [(Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''") + b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_print = function (a) {
        return "print(" + (Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_NONE) || "''") + ")\n";
    };
    Blockly.Python.text_prompt_ext = function (a) {
        var b = Blockly.Python.provideFunction_("text_prompt", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(msg):", "  try:", "    return raw_input(msg)", "  except NameError:", "    return input(msg)"]),
            c = a.getField("TEXT") ? Blockly.Python.quote_(a.getFieldValue("TEXT")) : Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_NONE) || "''";
        b = b + "(" + c + ")";
        "NUMBER" == a.getFieldValue("TYPE") && (b = "float(" + b + ")");
        return [b, Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_prompt = Blockly.Python.text_prompt_ext;
    Blockly.Python.text_count = function (a) {
        var b = Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''";
        a = Blockly.Python.valueToCode(a, "SUB", Blockly.Python.ORDER_NONE) || "''";
        return [b + ".count(" + a + ")", Blockly.Python.ORDER_FUNCTION_CALL];
    };
    Blockly.Python.text_replace = function (a) {
        var b = Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''",
            c = Blockly.Python.valueToCode(a, "FROM", Blockly.Python.ORDER_NONE) || "''";
        a = Blockly.Python.valueToCode(a, "TO", Blockly.Python.ORDER_NONE) || "''";
        return [b + ".replace(" + c + ", " + a + ")", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.text_reverse = function (a) {
        return [(Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_MEMBER) || "''") + "[::-1]", Blockly.Python.ORDER_MEMBER];
    };
    Blockly.Python.variables = {};
    Blockly.Python.variables_get = function (a) {
        return [Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME), Blockly.Python.ORDER_ATOMIC];
    };

    Blockly.Python.variables_set = function (a) {

        var b = Blockly.Python.valueToCode(a, "VALUE", Blockly.Python.ORDER_NONE) || "0";
        if (a.getInputTargetBlock() != null){

            if (a.getInputTargetBlock("VALUE").outputConnection.getCheck() == "DataFrame") {
                VarData[Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME)] = b;
            }
    
        }
        return Blockly.Python.variableDB_.getName(a.getFieldValue("VAR"), Blockly.VARIABLE_CATEGORY_NAME) + " = " + b + "\n";
    };
    Blockly.Python.variablesDynamic = {};
    Blockly.Python.variables_get_dynamic = Blockly.Python.variables_get;
    Blockly.Python.variables_set_dynamic = Blockly.Python.variables_set;
    return Blockly.Python;

});

/* ------------------------------ Global Variables section begins ------------------------------ */
var global_predicted_variable= "y_predicted";
var input = "x";
var output = "y";
var x_train = 'X_train';
var x_test = 'X_test';
var y_train = 'y_train';
var y_test = 'y_test';
var test_size = 'test_size';
var target_column = 'target_column'
/* ------------------------------ Global Variables section ends ------------------------------ */

/* ------------------------------ Classification Metrics section begins ------------------------------ */
Blockly.Python['f1score'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code =  `\nfrom sklearn.metrics import f1_score\nf1 = f1_score(${y_test},${global_predicted_variable}) \n`; +
                `print(f'F1 Score: {f1}')`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['recall'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code =  `\nfrom sklearn.metrics import recall_score\nrecall =recall_score(${y_test},${global_predicted_variable}) \n` +
                `print(f'Recall: {recall}')`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['precision'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `\nfrom sklearn.metrics import precision_score\nprecision = precision_score(${y_test},${global_predicted_variable}) \n` +
               `print(f'Precision: {precision}')`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 
Blockly.Python['accuracy'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code =  `\nfrom sklearn.metrics import accuracy_score\naccuracy = accuracy_score(${y_test},${global_predicted_variable}) \n` +
                `print(f'Accuracy: {accuracy}')`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 
/* ------------------------------ Classification Metrics section begins ------------------------------ */

Blockly.Python['evaluation'] = function(block) {
    var text_training_input = block.getFieldValue('predicted_variable');
    global_predicted_variable = text_training_input ;
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `${text_training_input}= model.predict(${x_test}) \n`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['training'] = function(block) {
    var text_training_input = block.getFieldValue('Training_input');
    var text_training_output = block.getFieldValue('Training_output');
    var code = `model.fit(${text_training_input},${text_training_output})\n`;
    if(text_training_input !=x_train){
        alert("wrong training input : "+text_training_input)
    }
    if(text_training_output != y_train){
        alert("wrong training input : "+text_training_output)
    }
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['classification_models'] = function(block) {
    var dropdown_algorithm = block.getFieldValue('c_algorithms');
    var text_dataset_path = block.getFieldValue('dataset_path');
    var value_data_preprocessing = Blockly.Python.valueToCode(block, 'Data_Preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_training = Blockly.Python.valueToCode(block, 'Model_Training', Blockly.Python.ORDER_FUNCTION_CALL) || '';
    var value_model_evaluation = Blockly.Python.valueToCode(block, 'Model_Evaluation', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_prediction = Blockly.Python.valueToCode(block, 'Model_Prediction', Blockly.Python.ORDER_ATOMIC) || '';
    var value_visualization = Blockly.Python.valueToCode(block, 'Visualization', Blockly.Python.ORDER_ATOMIC) || '';

    if(!value_data_preprocessing){
        alert("Add preprocess block");
    }
    if(!value_model_training){
        alert("Add training block");
    }
    
    var code = "";
    code += "import pandas as pd \n";
    switch (dropdown_algorithm) {
        case 'LogisticRegression':
            code += 'from sklearn.linear_model import LogisticRegression\n';
            code += 'model = LogisticRegression()\n';
            break;
            case 'Knn':
                var number_neighbors = block.getFieldValue('neighbors') || '';
                code += 'from sklearn.neighbors import KNeighborsClassifier\n';
                code += `model = KNeighborsClassifier(n_neighbors=${number_neighbors})\n`;
                break;
            case 'DecisionTrees':
                var max_depth_dt = block.getFieldValue('max_depth_dt') || '';
                code += 'from sklearn.tree import DecisionTreeClassifier\n';
                code += `model = DecisionTreeClassifier(max_depth=${max_depth_dt}, random_state=42)\n`;
                break;
            case 'RandomForest':
                var n_estimators = block.getFieldValue('n_estimators') || '';
                var max_depth_rf = block.getFieldValue('max_depth_rf') || '';
                code += 'from sklearn.ensemble import RandomForestClassifier\n';
                code += `model = RandomForestClassifier(n_estimators=${n_estimators}, max_depth=${max_depth_rf}, random_state=42)\n`;
                break;
            case 'Svm':
                var C = block.getFieldValue('C') || '1';
                var kernel = block.getFieldValue('kernel') || 'rbf';
                code += 'from sklearn.svm import SVC\n';
                code += `model = SVC(C=${C}, kernel='${kernel}')\n`;
                break;
            case 'NaiveBayes':
                code += 'from sklearn.naive_bayes import GaussianNB\n';
                code += 'model = GaussianNB()\n';
                break;
            case 'XGboost':
                var n_estimators_xgb = block.getFieldValue('n_estimators_xgb') ||'';
                var max_depth_xgb = block.getFieldValue('max_depth_xgb') || '';
                var learning_rate = block.getFieldValue('learning_rate') || '';
                code += 'import xgboost as xgb\n';
                code += `model = xgb.XGBClassifier(n_estimators=${n_estimators_xgb}, max_depth=${max_depth_xgb}, learning_rate=${learning_rate}, random_state=42)\n`;
                break;
            default:
            break;
    }
    
    code += '\n';
    code += `data = pd.read_csv('${text_dataset_path}')\n`;
    code += value_data_preprocessing + '\n';
    code += value_model_training + '\n';
    code += value_model_evaluation + '\n';
    code += value_model_prediction + '\n';
    code += value_visualization + '\n';

    // make sure that only correct visualization has been added
    var wrong_logistic = [
        "# Decision Boundary Plot",
        "# Tree Visualization (Decision Tree Classification)",
        "# Feature Importances (Random Forest Classification)",
        "# Confusion Matrix for neural network models",
        "# ROC Curve for neural network models",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error"
    ];

    var wrong_DecisionTrees = [
        "# Decision Boundary Plot",
        "# Feature Importances (Random Forest Classification)",
        "# Confusion Matrix for neural network models",
        "# ROC Curve for neural network models",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error"
    ];

    var wrong_RandomForest = [
        "# Decision Boundary Plot",
        "# Tree Visualization (Decision Tree Classification)",
        "# Confusion Matrix for neural network models",
        "# ROC Curve for neural network models",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods"
    ];

    var wrong_XGboost = [
        "# Decision Boundary Plot",
        "# Tree Visualization (Decision Tree Classification)",
        "# Feature Importances (Random Forest Classification)",
        "# Confusion Matrix for neural network models",
        "# ROC Curve for neural network models",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error"
    ];

    function containsAnySentence(value, sentences) {
    for (var i = 0; i < sentences.length; i++) {
        if (value.includes(sentences[i])) {
            return true;
        }
    }
    return false;
    }
    
    if ((dropdown_algorithm == "LogisticRegression" || dropdown_algorithm == "Knn" || dropdown_algorithm == "Svm" || dropdown_algorithm == "NaiveBayes") && containsAnySentence(value_visualization, wrong_logistic)) {
        alert("these visualizations can not be used with logistic regression, KNN, Naive Bayes SVM Models:\nDecision Boundary Plot, Tree Visualization, Feature Importances, Precision-Recall Curve\nneural network models, Ensemble Methods");
    }
    else if (dropdown_algorithm == "DecisionTrees" && containsAnySentence(value_visualization, wrong_DecisionTrees)) {
        alert("these visualizations can not be used with Decision Trees Model:\nDecision Boundary Plot, Feature Importances\nneural network models, Ensemble Methods");
    }
    else if (dropdown_algorithm == "RandomForest" && containsAnySentence(value_visualization, wrong_RandomForest)) {
        alert("these visualizations can not be used with RandomForest Model:\nDecision Boundary Plot, Tree Visualization\nneural network models, Feature Importance from Ensemble Methods");
    }
    if (dropdown_algorithm == "XGboost" && containsAnySentence(value_visualization, wrong_XGboost)) {
        alert("these visualizations can not be used with Gradient Boosting Model:\nDecision Boundary Plot, Tree Visualization, Feature Importances\nneural network models, Out-of-Bag Error");
    }

    return code;
};  


Blockly.Python['regression_models'] = function(block) {
    var dropdown_algorithm = block.getFieldValue('r_algorithms');
    var text_dataset_path = block.getFieldValue('dataset_path');
    var value_data_preprocessing = Blockly.Python.valueToCode(block, 'Data_Preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_training = Blockly.Python.valueToCode(block, 'Model_Training', Blockly.Python.ORDER_FUNCTION_CALL) || '';
    var value_model_evaluation = Blockly.Python.valueToCode(block, 'Model_Evaluation', Blockly.Python.ORDER_ATOMIC) || '';
    var value_model_prediction = Blockly.Python.valueToCode(block, 'Model_Prediction', Blockly.Python.ORDER_ATOMIC) || '';
    var value_visualization = Blockly.Python.valueToCode(block, 'Visualization', Blockly.Python.ORDER_ATOMIC) || '';

    if(!value_data_preprocessing){
        alert("Add preprocess block");
    }
    if(!value_model_training){
        alert("Add training block");
    }

    var code = "";
    code += "import pandas as pd\n";
    switch (dropdown_algorithm) {
        case 'LinearRegression':
            code += 'from sklearn.linear_model import LinearRegression\n';
            code += 'model = LinearRegression()\n';
            break;
        case 'DecisionTree':
            var max_depth_dt = block.getFieldValue('max_depth_dt') || '';
            code += 'from sklearn.tree import DecisionTreeRegressor\n';
            code += `model = DecisionTreeRegressor(max_depth=${max_depth_dt}, random_state=42)\n`;
            break;
        case 'RandomForest':
            var n_estimators_rf = block.getFieldValue('n_estimators_rf') || '';
            var max_depth_rf = block.getFieldValue('max_depth_rf') || '';
            code += 'from sklearn.ensemble import RandomForestRegressor\n';
            code += `model = RandomForestRegressor(n_estimators=${n_estimators_rf}, max_depth=${max_depth_rf}, random_state=42)\n`;
            break;
        case 'SVM':
            var c_svm = block.getFieldValue('C_svm') || '';
            var kernel_svm = block.getFieldValue('kernel_svm') || '';
            code += 'from sklearn.svm import SVR\n';
            code += `model = SVR(C=${c_svm}, kernel='${kernel_svm}')\n`;
            break;
        case 'GradientBoosting':
            var n_estimators_gb = block.getFieldValue('n_estimators_gb') || '';
            var max_depth_gb = block.getFieldValue('max_depth_gb') || '';
            var learning_rate_gb = block.getFieldValue('learning_rate_gb') || '';
            code += 'from sklearn.ensemble import GradientBoostingRegressor\n';
            code += `model = GradientBoostingRegressor(n_estimators=${n_estimators_gb}, max_depth=${max_depth_gb}, learning_rate=${learning_rate_gb}, random_state=42)\n`;
            break;
        default:
            break;
    }
    
    code += '\n';
    code += `data = pd.read_csv('${text_dataset_path}')\n`;
    code += value_data_preprocessing + '\n';
    code += value_model_training + '\n';
    code += value_model_evaluation + '\n';
    code += value_model_prediction + '\n';
    code += value_visualization + '\n';

    // make sure that only correct visualization has been added
    var wrong = [
        "# Tree Visualization (Decision Tree Classification)",
        "# Feature Importances (Random Forest Classification)",
        "# Confusion Matrix for classical models",
        "# ROC Curve for classical models",
        "# Confusion Matrix for neural network models",
        "# ROC Curve for neural network models",
        "# Precision-Recall Curve for classical models",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error"
    ];

    function containsAnySentence(value, sentences) {
        for (var i = 0; i < sentences.length; i++) {
            if (value.includes(sentences[i])) {
                return true;
            }
        }
        return false;
    }

    if (containsAnySentence(value_visualization, wrong)) {
        alert("these visualizations can not be used with Regression Models:\nTree Visualization, Feature Importances, Confusion Matrix and ROC Curve\nneural network models,hyperparameter heatmaps and Ensemble Methods");
    }

    return code;
};


Blockly.Python['mae'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import mean_absolute_error\n`;
    code += `mae = mean_absolute_error(${y_test}, ${global_predicted_variable})\n`;
    code += `print(f'Mean Absolute Error: {mae}')\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};
Blockly.Python['mse'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import mean_squared_error\n`;
    code += `mse = mean_squared_error(${y_test}, ${global_predicted_variable})\n`;
    code += `print(f'Mean Squared Error: {mse}')\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};
  
Blockly.Python['r_squared'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import r2_score\n`;
    code += `r_squared = r2_score(${y_test}, ${global_predicted_variable})\n`;
    code += `print(f'R-Squared: {r_squared}')\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};

/* ------------------------------ Deep Learning Blocks begins ------------------------------ */
/* Sequential Model begins */
Blockly.Python['sequential'] = function(block) {
    var dataset_path = block.getFieldValue('dataset_path');
    var data_preprocessing = Blockly.Python.valueToCode(block, 'data_Preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
    var layers = Blockly.Python.valueToCode(block, 'layers', Blockly.Python.ORDER_ATOMIC) || '';
    var compile = Blockly.Python.valueToCode(block, 'compile', Blockly.Python.ORDER_ATOMIC) || '';
    var fit = Blockly.Python.valueToCode(block, 'fit', Blockly.Python.ORDER_ATOMIC) || '';
    var evaluate = Blockly.Python.valueToCode(block, 'evaluate', Blockly.Python.ORDER_ATOMIC) || '';
    var visualization = Blockly.Python.valueToCode(block, 'visualization', Blockly.Python.ORDER_ATOMIC) || '';

    if(!data_preprocessing){
        alert("Add preprocess block");
    }
    if(!layers){
        alert("Add layers block");
    }
    if(!compile){
        alert("Add compile block");
    }
    if(!fit){
        alert("Add fit block");
    }
  
    var code = `import numpy as np\nimport pandas as pd\nfrom tensorflow.keras.models import Sequential\n\n`;
    if (layers) {
        code += `from tensorflow.keras.layers import Dense\n`;
    }
    code += `# Load the dataset from a CSV file\n`;
    code += `dataset_path = "${dataset_path}"\n`;
    code += `data = pd.read_csv(dataset_path)\n\n`;
    code += data_preprocessing;
    if (layers) {
        code += `model = Sequential([\n`;
        code += layers;
        code += `\n])\n`;
    }
    code += compile;
    code += fit;
    code += evaluate;
    code += visualization;
    
    // make sure that only correct visualization has been added
    var wrong = [
        "# Tree Visualization (Decision Tree Classification)",
        "# Feature Importances (Random Forest Classification)",
        "# Learning Curves for classical models",
        "# Confusion Matrix for classical models",
        "# ROC Curve for classical models",
        "# Confusion Matrix for neural network models",
        "# ROC Curve for neural network models",
        "# Precision-Recall Curve for classical models",
        "# Hyperparameter Heatmaps",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error"
    ];

    function containsAnySentence(value, sentences) {
    for (var i = 0; i < sentences.length; i++) {
        if (value.includes(sentences[i])) {
            return true;
        }
    }
    return false;
    }
    
    if (containsAnySentence(visualization, wrong)) {
        alert("Only these visualizations can be used with Sequential Model:\nScatter Plot, Histograms, Heatmaps, Box Plots\nfor neural network: Loss and accuracy curves, Learning Curves\nTSNE, PCA, Elbow Plot");
    }


    return code;
};
/* Sequential Model ends */

var layersFlag = []

/* CNN Model begins */
Blockly.Python['cnn_model'] = function(block) {
    var training_path = block.getFieldValue('training_path');
    var test_path = block.getFieldValue('test_path');

    var trainAug = Blockly.Python.valueToCode(block, 'trainAug', Blockly.Python.ORDER_ATOMIC) || '';
    var testAug = Blockly.Python.valueToCode(block, 'testAug', Blockly.Python.ORDER_ATOMIC) || '';

    var trainGen = Blockly.Python.valueToCode(block, 'trainGen', Blockly.Python.ORDER_ATOMIC) || '';
    var testGen = Blockly.Python.valueToCode(block, 'testGen', Blockly.Python.ORDER_ATOMIC) || '';

    var layers = Blockly.Python.valueToCode(block, 'layers', Blockly.Python.ORDER_ATOMIC) || '';
    var compile = Blockly.Python.valueToCode(block, 'cnnCompile', Blockly.Python.ORDER_ATOMIC) || '';
    var fit = Blockly.Python.valueToCode(block, 'cnnFit', Blockly.Python.ORDER_ATOMIC) || '';
    var evaluate = Blockly.Python.valueToCode(block, 'cnnEvaluate', Blockly.Python.ORDER_ATOMIC) || '';
    var visualization = Blockly.Python.valueToCode(block, 'visualization', Blockly.Python.ORDER_ATOMIC) || '';

    var code = `from tensorflow.keras.models import Sequential\n`;

    if(!layers){
        alert("Add layers block");
    }
    if(!compile){
        alert("Add compile block");
    }
    if(!fit){
        alert("Add fit block");
    }

    if (trainAug||testAug) {
        code += `from tensorflow.keras.preprocessing.image import ImageDataGenerator\n\n`;
    }


    if(layers && layersFlag.includes("MaxPooling2D")){code+='from tensorflow.keras.layers import MaxPooling2D\n'}
    if(layers && layersFlag.includes("AveragePooling2D")){code+='from tensorflow.keras.layers import AveragePooling2D\n'}
    if(layers && layersFlag.includes("Conv2d")){code+='from tensorflow.keras.layers import Conv2D\n'}
    if(layers && layersFlag.includes("Dense")){code+='from tensorflow.keras.layers import Dense\n'}
    if(layers && layersFlag.includes("flatten")){code+='from tensorflow.keras.layers import Flatten\n'}
    if(layers && layersFlag.includes("dropout")){code+='from tensorflow.keras.layers import Dropout\n'}
    
    code += `\ntrain_dir = '${training_path}'\nvalidation_dir = '${test_path }'\n\n`
    
    if (trainAug) {
        code += `train_datagen = ImageDataGenerator( `;
        code += trainAug;
        code += `\n)\n`;
    }
    if (testAug) {
        code += `test_datagen = ImageDataGenerator(`;
        code += testAug;
        code += `\n)\n`;
    }
    if (trainGen) {
        code += `train_generator = train_datagen.flow_from_directory(train_dir,\n`;
        code += trainGen;
        code += `\n)\n`;
        if (!trainGen.includes("target_size")) {
            alert("You must specify target size for training generator");
          }
    }
    if (testGen) {
        code += `test_generator = test_datagen.flow_from_directory(validation_dir,\n`;
        code += testGen;
        code += `\n)\n`;
        if (!testGen.includes("target_size")) {
            alert("You must specify target size for test generator");
          }
    }

    if (layers) {
        code += `model = Sequential([\n`;
        code += layers;
        code += `\n])\n`;
    }


    code += compile;
    code += fit;
    code += evaluate;
    code += visualization;
     
    // make sure that only correct visualization has been added
    var wrong = [
        "# Box Plots",
        "# Decision Boundary Plot",
        "# Feature Importances (Random Forest Classification)",
        "# Learning Curves for classical models",
        "# Confusion Matrix for classical models",
        "# ROC Curve for classical models",
        "# ROC Curve for neural network models",
        "# Precision-Recall Curve for classical models",
        "# Hyperparameter Heatmaps",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error",
        "# Elbow Plot",
        "# TSNE Plot",
        "## PCA Plot"
    ];

    function containsAnySentence(value, sentences) {
    for (var i = 0; i < sentences.length; i++) {
        if (value.includes(sentences[i])) {
            return true;
        }
    }
    return false;
    }
    
    if (containsAnySentence(visualization, wrong)) {
        alert("Only these visualizations can be used with CNN Model:\nScatter Plot, Histograms, Heatmaps\nfor neural network: Loss and accuracy curves, Learning Curves, Confusion Matrix");
    }

    return code;
};

/* CNN Model ends */

/* SOM MODEL begins */
Blockly.Python['som'] = function(block) {
    var dataset_path = block.getFieldValue('dataset_path');
    var preprocessing = Blockly.Python.valueToCode(block, 'input_output', Blockly.Python.ORDER_ATOMIC) || '';
    var encoding = Blockly.Python.valueToCode(block, 'encoding', Blockly.Python.ORDER_ATOMIC) || '';
    var splitting = Blockly.Python.valueToCode(block, 'split', Blockly.Python.ORDER_ATOMIC) || '';
    var som_evaluate = Blockly.Python.valueToCode(block, 'som_evaluation', Blockly.Python.ORDER_ATOMIC) || '';
    var som_assign = Blockly.Python.valueToCode(block, 'som_assign', Blockly.Python.ORDER_ATOMIC) || '';
    var som_init = Blockly.Python.valueToCode(block, 'som_init', Blockly.Python.ORDER_ATOMIC) || '';
    var metrics = Blockly.Python.valueToCode(block, 'metrics', Blockly.Python.ORDER_ATOMIC) || '';
    var value_visualization = Blockly.Python.valueToCode(block, 'Visualization', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `import numpy as np\n` +
               `import pandas as pd\n` +
               `from minisom import MiniSom\n` +
               `from sklearn.model_selection import train_test_split\n` +
               `from sklearn.preprocessing import StandardScaler\n`;

    code += `\n# Load the dataset from a CSV file\n` +
            `dataset_path = "${dataset_path}"\n` +
            `data = pd.read_csv(dataset_path)\n\n` +
            `# Prepare features and target\n`;
    
    // make sure that user dropped Preprocessing blocks
    if(preprocessing){
        code += preprocessing + '\n';
    }else{
        alert("Please add Preprocessing blocks and data splitting block");
    }
    /*
    code += encoding + '\n';

    // make sure that user dropped data split block after input - output block
    if(splitting && input_output){
        code += splitting + '\n';
    }else if(splitting && !input_output){
        alert("Please add Preprocessing blocks first");
    }else if(!splitting && input_output){
        alert("Please add data splitting block");
    }
*/
    // make sure that user dropped SOM Initialization block
    if(preprocessing && som_init){
        code += som_init;
    }else if(!preprocessing && som_init){
        alert("Please add Preprocessing and data splitting blocks first to be able to add initialization block");
    }
    
    // make sure that user dropped SOM Initialization block before Assign block
    if(preprocessing && som_init && som_assign){
        code += som_assign;
    }else if(!som_init && som_assign){
        alert("Please add initialization block before adding assign block");
    }

    code += som_evaluate + '\n';

    // make sure that user dropped Evaluation Block before using metrics blocks
    if(metrics && som_evaluate){
        code += metrics + '\n';
    }else if(metrics && !som_evaluate){
        alert("Please add Evaluation Block before using metrics blocks");
    }

    // make sure that user dropped Evaluation Block before using metrics blocks
    if(value_visualization && som_evaluate){
        code += value_visualization + '\n';
    }else if(value_visualization && !som_evaluate){
        alert("Please add Evaluation Block before using visualization blocks");
    }

    // make sure that only correct visualization has been added
    var wrong = [
        "# Decision Boundary Plot",
        "# Tree Visualization (Decision Tree Classification)",
        "# Feature Importances (Random Forest Classification)",
        "# Learning Curves",
        "# Confusion Matrix for classical models",
        "# ROC Curve for classical models",
        "# Precision-Recall Curve for classical models",
        "# Elbow Plot",
        "# TSNE Plot",
        "# PCA Plot",
        "# Hyperparameter Heatmaps",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error"
    ];

    function containsAnySentence(value, sentences) {
    for (var i = 0; i < sentences.length; i++) {
        if (value.includes(sentences[i])) {
            return true;
        }
    }
    return false;
    }
    
    if (containsAnySentence(value_visualization, wrong)) {
        alert("Only these visualizations can be used with SOM Model:\nScatter Plot, Histograms, Heatmaps, Box Plots\nfor neural network: Confusion Matrix, ROC Curve, Precision_Recall Curve");
    }

    return code;
};

/* SOM Model ends */

/* SOM Blocks begins */
Blockly.Python['som_evaluation'] = function(block) {
    var text_training_input = block.getFieldValue('predicted_variable');
    global_predicted_variable = text_training_input ;

    var code =  `# Predict clusters for the test set based on the trained SOM\n` +
                `${global_predicted_variable} = []\n` +
                `for ${input} in ${x_test}:\n` +
                `    w = som.winner(${input})\n` +
                `    ${global_predicted_variable}.append(neuron_labels[w])\n\n`;

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

Blockly.Python['som_init'] = function(block) {
    var x_neurons = block.getFieldValue('x_neurons');
    var y_neurons = block.getFieldValue('y_neurons');
    var sigma = block.getFieldValue('sigma');
    var learning_rate = block.getFieldValue('learning_rate');
    
    var code =  `# Initialize the SOM\n` +
                `som_x, som_y = ${x_neurons}, ${y_neurons}\n` +
                `som = MiniSom(x=${x_neurons}, y=${y_neurons}, input_len=${x_train}.shape[1], sigma=${sigma}, learning_rate=${learning_rate})\n` +
                `som.random_weights_init(${x_train})\n\n`;

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['som_assign'] = function(block) {
    var dropdown_label_assign = block.getFieldValue('label_assign');
    var code ='';
    
    switch (dropdown_label_assign) {
        case 'most_common':
            code += `from collections import defaultdict\n` +
                    `# Assign each neuron the most common label in its neighborhood\n` +
                    `neuron_labels = defaultdict(list)\n` +
                    `for i, x in enumerate(X_train):\n` +
                    `    w = som.winner(x)\n` +
                    `    neuron_labels[w].append(y_train[i])\n\n` +
                    `# Determine the most common label for each neuron\n` +
                    `for w in neuron_labels:\n` +
                    `    neuron_labels[w] = np.bincount(neuron_labels[w]).argmax()\n`;
            break;
        case 'mean_value':
            code += `from collections import defaultdict\n` +
                    `# Assign each neuron the mean value of labels in its neighborhood\n` +
                    `neuron_labels = defaultdict(list)\n` +
                    `for i, x in enumerate(X_train):\n` +
                    `    w = som.winner(x)` +
                    `    neuron_labels[w].append(y_train[i])\n\n` +
                    `# Determine the mean value for each neuron\n` +
                    `for w in neuron_labels:\n` +
                    `    neuron_labels[w] = np.mean(neuron_labels[w])\n`;
            break;
        default:
        break;
    }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };


  Blockly.Python['quantization_error'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code =  `# Quantization Error\n` +
                `quantization_error = som.quantization_error(${x_train})\n` +
                `print(f'Quantization Error: {quantization_error}')\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['topographic_error'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code =  `# Topographic Error\n` +
                `def topographic_error(som, data):\n` +
                `    error_count = 0\n` +
                `    for ${input} in data:\n` +
                `        winner = som.winner(${input})\n` +
                `        distances = []\n` +
                `        for i in range(som_${input}):\n` +
                `            for j in range(som_${output}):\n` +
                `                distances.append(((i, j), np.linalg.norm(som.get_weights()[i, j] - ${input})))\n` +
                `        distances.sort(key=lambda ${input}: ${input}[1])\n` +
                `        second_winner = distances[1][0]\n` +
                `        if abs(winner[0] - second_winner[0]) > 1 or abs(winner[1] - second_winner[1]) > 1:\n` +
                `            error_count += 1\n` +
                `    return error_count / len(data)\n` +
                `topographic_error_value = topographic_error(som, ${x_train})\n` +
                `print(f'Topographic Error: {topographic_error_value}')\n`;

    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};
/* SOM Blocks ends */

/* ------------------------------ Deep Learning Blocks ends ------------------------------ */

///////////////////////////////////////////LAYERS///////////////////////////////////////////////////////   
Blockly.Python['Conv2D'] = function(block) {
    var filters = block.getFieldValue('filters');
    var size1 = block.getFieldValue('size1');
    var size2 = block.getFieldValue('size2');
    var activation = block.getFieldValue('activation');
    var input = Blockly.Python.valueToCode(block, 'Conv2D', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `Conv2D(${filters} , (${size1}, ${size2}), activation='${activation}')`;
    
    if (input) {
        code += `,\n${input}`;
      }
    if (!layersFlag.includes("Conv2d")){layersFlag.push("Conv2d")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['Conv2Dfirst'] = function(block) {
    var filters = block.getFieldValue('filters_number');
    var size1 = block.getFieldValue('f_size1');
    var size2 = block.getFieldValue('f_size2');
    var activation = block.getFieldValue('activation_function');
    var input_size1 = block.getFieldValue('input_size1');
    var input_size2 = block.getFieldValue('input_size2');
    var input_size3 = block.getFieldValue('input_size3');
    var input = Blockly.Python.valueToCode(block, 'Conv2Dfirst', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `Conv2D(${filters} , (${size1}, ${size2}), activation='${activation}',input_shape=(${input_size1}, ${input_size2}, ${input_size3 }))`;
    
    if (input) {
        code += `,\n${input}`;
      }
    if (!layersFlag.includes("Conv2d")){layersFlag.push("Conv2d")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['averagepooling2d'] = function(block) {
    var size1 = block.getFieldValue('size1');
    var size2 = block.getFieldValue('size2');
    var stride1 = block.getFieldValue('stride1');
    var stride2 = block.getFieldValue('stride2');
    var input = Blockly.Python.valueToCode(block, 'AveragePooling2D', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'AveragePooling2D(pool_size=(' + size1 + ', ' + size2 + '), strides=(' + stride1 + ', ' + stride2 + '))';
    
    if (input) {
        code += `,\n${input}`;
      }
    if (!layersFlag.includes("AveragePooling2D")){layersFlag.push("AveragePooling2D")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['maxpooling2d'] = function(block) {
    var size1 = block.getFieldValue('size1');
    var size2 = block.getFieldValue('size2');
    var stride1 = block.getFieldValue('stride1');
    var stride2 = block.getFieldValue('stride2');
    var input = Blockly.Python.valueToCode(block, 'MaxPooling2D', Blockly.Python.ORDER_ATOMIC) || '';

    var code = 'MaxPooling2D(pool_size=(' + size1 + ', ' + size2 + '), strides=(' + stride1 + ', ' + stride2 + '))';
    if (input) {
      code += `,\n${input}`;
    }

    if (!layersFlag.includes("MaxPooling2D"))
        {layersFlag.push("MaxPooling2D")}

    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['dense'] = function(block) {
    var neuron_number = block.getFieldValue('neuron_number');
    var activation = block.getFieldValue('activation');
    var dense_input = Blockly.Python.valueToCode(block, 'Dense', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `Dense(${neuron_number}, activation='${activation}')`;
    
    // If there is an input value, append it to the code
    if (dense_input) {
      code += `,\n${dense_input}`;
    }
    if (!layersFlag.includes("Dense")){layersFlag.push("Dense")}
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['flatten'] = function(block) {
 var input = Blockly.Python.valueToCode(block, 'flatten_input', Blockly.Python.ORDER_ATOMIC) || '';

    var code = 'Flatten()';
    if (input) {
      code += `,\n${input}`;
    }

    if (!layersFlag.includes("flatten"))
        {layersFlag.push("flatten")}

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['dropout'] = function(block) {
    var text_rate = block.getFieldValue('rate');
    var input = Blockly.Python.valueToCode(block, 'dropout', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `Dropout(${text_rate})`;
    if (input) {
      code += `,\n${input}`;
    }

    if (!layersFlag.includes("dropout"))
        {layersFlag.push("dropout")}

    return [code, Blockly.Python.ORDER_ATOMIC];
  };
////////////////////////////////////////////////Augmentation/////////////////////////////////////////////////
Blockly.Python['rescale'] = function(block) {
    var rescale = block.getFieldValue('rescale');
    var input = Blockly.Python.valueToCode(block, 'rescale', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `rescale= ${rescale}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['shear_range'] = function(block) {
    var shear_range = block.getFieldValue('shear_range');
    var input = Blockly.Python.valueToCode(block, 'shear_range', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `shear_range= ${ shear_range}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['zoom_range'] = function(block) {
    var zoom_range = block.getFieldValue('zoom_range');
    var input = Blockly.Python.valueToCode(block, 'zoom_range', Blockly.Python.ORDER_ATOMIC) || '';

    var code = `zoom_range= ${zoom_range}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['rotation_range'] = function(block) {
    var rotation_range = block.getFieldValue('rotation_range');
    var input = Blockly.Python.valueToCode(block, 'rotation_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `rotation_range= ${rotation_range}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['width_shift_range'] = function(block) {
    var width_shift_range = block.getFieldValue('width_shift_range');
    var input = Blockly.Python.valueToCode(block, 'width_shift_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `width_shift_range= ${width_shift_range}`;
    
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['height_shift_range'] = function(block) {
    var height_shift_range = block.getFieldValue('height_shift_range');
    var input = Blockly.Python.valueToCode(block, 'height_shift_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `height_shift_range= ${height_shift_range}`;
    
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['channel_shift_range'] = function(block) {
    var channel_shift_range = block.getFieldValue('channel_shift_range');
    var input = Blockly.Python.valueToCode(block, 'channel_shift_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `channel_shift_range= ${channel_shift_range}`;
    
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['horizontal_flip'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'horizontal_flip', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'horizontal_flip=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['vertical_flip'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'vertical_flip', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'vertical_flip=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['featurewise_center'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'featurewise_center', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'featurewise_center=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['featurewise_std_normalization'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'featurewise_std_normalization', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'featurewise_std_normalization=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['samplewise_std_normalization'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'samplewise_std_normalization', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'samplewise_std_normalization=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['samplewise_center'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'samplewise_center', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'samplewise_center=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['zca_whitening'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'zca_whitening', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = 'zca_whitening=True';
    if (input) {
        code += `,\n${input}`;
      }
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['brightness_range'] = function(block) {
    var brightness_min = block.getFieldValue('brightness_min');
    var brightness_max = block.getFieldValue('brightness_max');
    var input = Blockly.Python.valueToCode(block, 'brightness_range', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = `brightness_range=[ ${brightness_min} , ${brightness_max} ]`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['fill_mode'] = function(block) {
    var fill_mode = block.getFieldValue('fill_mode');
    var input = Blockly.Python.valueToCode(block, 'fill_mode', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `fill_mode='${fill_mode}'s`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
//////////////////////////////////////////////////Generators///////////////////////////////////////////////
Blockly.Python['color_mode'] = function(block) {
    var color_mode = block.getFieldValue('color_mode');
    var input = Blockly.Python.valueToCode(block, 'color_mode', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `color_mode='${color_mode}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['interpolation'] = function(block) {
    var interpolation = block.getFieldValue('interpolation');
    var input = Blockly.Python.valueToCode(block, 'interpolation', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `interpolation='${interpolation}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['subset'] = function(block) {
    var subset = block.getFieldValue('subset');
    var input = Blockly.Python.valueToCode(block, 'subset', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `subset='${subset}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['shuffle'] = function(block) {
var input = Blockly.Python.valueToCode(block, 'shuffle', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `shuffle= True`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['augment'] = function(block) {
    var input = Blockly.Python.valueToCode(block, 'augment', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `augment = True`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['save_format'] = function(block) {
    var save_format = block.getFieldValue('save_format');
    var input = Blockly.Python.valueToCode(block, 'save_format', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `save_format= '${save_format}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['seed'] = function(block) {
    var seed = block.getFieldValue('seed');
    var input = Blockly.Python.valueToCode(block, 'seed', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `seed= ${seed}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['save_to_dir'] = function(block) {
    var save_to_dir = block.getFieldValue('save_to_dir');
    var input = Blockly.Python.valueToCode(block, 'save_to_dir', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `save_to_dir= '${save_to_dir}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['save_prefix'] = function(block) {
    var save_prefix = block.getFieldValue('save_prefix');
    var input = Blockly.Python.valueToCode(block, 'save_prefix', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `save_prefix= '${save_prefix}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['class_mode'] = function(block) {
    var class_mode = block.getFieldValue('class_mode');
    var input = Blockly.Python.valueToCode(block, 'class_mode', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `class_mode = '${class_mode}'`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['target_size'] = function(block) {
    var target_size1 = block.getFieldValue('target_size1');
    var target_size2 = block.getFieldValue('target_size2');
    var input = Blockly.Python.valueToCode(block, 'target_size', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `target_size = (${target_size1},${target_size2})`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['batch_size'] = function(block) {
    var batch_size = block.getFieldValue('batch_size');
    var input = Blockly.Python.valueToCode(block, 'batch_size', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `batch_size = ${batch_size}`;
    if (input) {
        code += `,\n${input}`;
      }
    return [code, Blockly.Python.ORDER_ATOMIC];
  }; 
/////////////////////////////////// FITING //////////////////////////////////////////////////////////
  Blockly.Python['fit'] = function(block) {
    var x_Ftrain = block.getFieldValue('X_train');
    var y_Ftrain = block.getFieldValue('y_train');
    var epochs = block.getFieldValue('epochs');
    var verbose = block.getFieldValue('verbose');
  if(x_Ftrain != x_train){
    alert("Wrong input : "+x_Ftrain)
  }
  if(y_Ftrain != y_train){
    alert("Wrong input : "+y_Ftrain)
  }
    var code = `model.fit(${x_Ftrain}, ${y_Ftrain}, epochs=${epochs}, verbose=${verbose})\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['cnn_fit'] = function(block) {
    var epochs = block.getFieldValue('cnn_epochs');
    var verbose = block.getFieldValue('cnn_verbose');
  
    var code = `model.fit(train_generator, epochs=${epochs}, validation_data= test_generator, verbose=${verbose} )\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['rnn_fit'] = function(block) {
    var epochs = block.getFieldValue('rnn_epochs');
    var verbose = block.getFieldValue('rnn_verbose');
  
    var code = `model.fit(X_train, y_train, epochs=${epochs}, validation_data=(X_test,y_test), verbose=${verbose} )\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  /////////////////////////////////EVALUATION ////////////////////////////////////////////////
  Blockly.Python['evaluate'] = function(block) {
    var x_Ftest = block.getFieldValue('X_test');
    var y_Ftest = block.getFieldValue('y_test');
    if(x_Ftest != x_test){
        alert("Wrong input : "+x_Ftest)
      }
      if(y_Ftest  != y_test ){
        alert("Wrong input : "+y_Ftest)
      }
    var code = `model.evaluate(${x_Ftest}, ${y_Ftest})\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['cnn_evaluation'] = function(block) {
    var code = `model.evaluate(test_generator)\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  Blockly.Python['RNN_evaluation'] = function(block) {
    var code = `model.evaluate(X_test,y_test)\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  
     Blockly.Python['compile'] = function(block) {
    var optimizer = block.getFieldValue('optimizer');
    var loss = block.getFieldValue('loss');
    var metrics = block.getFieldValue('metrics');
  
    var code = `model.compile(optimizer='${optimizer}', loss='${loss}', metrics=['${metrics}'])\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
Blockly.Python['data_split'] = function(block) {
    x_train = block.getFieldValue('X_train');
    x_test = block.getFieldValue('X_test');
    y_train = block.getFieldValue('y_train');
    y_test = block.getFieldValue('y_test');
    test_size = block.getFieldValue('test_size');
    var code = 'from sklearn.model_selection import train_test_split;\n'
    code += `${x_train}, ${x_test}, ${y_train}, ${y_test} = train_test_split(${input}, ${output}, test_size=${test_size}, random_state=42);\n`
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['input_output'] = function(block) {
    var value_preprocessing = Blockly.Python.valueToCode(block,'input_output', Blockly.Python.ORDER_ATOMIC) || '';
    input = block.getFieldValue('input_variable');
    output = block.getFieldValue('output_variable');
    target_column = block.getFieldValue('target_column');

    var code = `${input} = data.drop(columns=['${target_column}'], axis=1);\n`
    code += `${output} = data['${target_column}'];\n`
    code += value_preprocessing + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['prediction'] = function(block) {
    var input_data = block.getFieldValue('input_data');

    var code = `predictions = model.predict(${input_data})\n`;
    return [code, Blockly.Python.ORDER_ATOMIC];
};

/* Visualization Blocks begins */
/* ------------------------------ Data Visualization begins ------------------------------ */

Blockly.Python['scatter_plot'] = function(block) {
    var scatter_plot_input = Blockly.Python.valueToCode(block, 'scatter_plot', Blockly.Python.ORDER_ATOMIC) || '';
    var cnn = block.getFieldValue('cnn') === 'TRUE';

    if (cnn) {
        var code =  `# Scatter plot\n` +
                    `# Get true labels and predictions from the test generator\n` +
                    `${y_test} = test_generator.classes\n` +
                    `y_pred_prob = model.predict(test_generator)\n` +
                    `${global_predicted_variable} = np.argmax(y_pred_prob, axis=1)\n` +
                    `fig, ax = plt.subplots()  # Create a figure and axis object\n\n` +
                    `# Scatter plot for actual values\n` +
                    `ax.scatter(x=range(len(${y_test})), ${output}=${y_test}, c='blue', label='Actual', alpha=0.3)\n\n` +
                    `# Scatter plot for predicted values\n` +
                    `ax.scatter(x=range(len(${global_predicted_variable})), ${output}=${global_predicted_variable}, c='red', label='Predicted', alpha=0.3)\n\n` +
                    `ax.set_title('Scatter Plot of Actual vs Predicted Values')\n` +
                    `ax.set_xlabel('Index')\n` +
                    `ax.set_ylabel('Class')\n` +
                    `ax.legend()\n` +
                    `plt.show()\n`;
    }else {
        var code =  '# Scatter plot\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'fig, ax = plt.subplots() # Create a figure and axis object\n' +
                    '\n# Scatter plot for actual values\n' +
                    `ax.scatter(${input}=range(0, len(${y_test})), ${output}=${y_test}, c=\'blue\', label=\'Actual\', alpha=0.3)\n` +
                    '\n# Scatter plot for predicted values\n' +
                    `ax.scatter(${input}=range(0, len(${global_predicted_variable})), ${output}=${global_predicted_variable}, c=\'red\', label=\'Predicted\', alpha=0.3)\n`
                    '# Set plot title and labels\n' +
                    'plt.title(\'Actual and Predicted Values\')\n' +
                    'plt.xlabel(\'Actual Values\')\n' +
                    'plt.ylabel(\'Predicted Values\')\n' +
                    'plt.legend() # Display legend\n' +
                    'plt.show() # Show the plot\n';
    }
    // If there is an input value, append it to the code
    if (scatter_plot_input) {
        code += `\n${scatter_plot_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['histograms'] = function(block) {
    var histograms_input = Blockly.Python.valueToCode(block, 'histograms', Blockly.Python.ORDER_ATOMIC) || '';
    var som = block.getFieldValue('som') === 'TRUE';
    var cnn = block.getFieldValue('cnn') === 'TRUE';

    if (som && cnn) {
        alert("You can't select two models in histogram visualization block");
    }

    if (som) {
        var code =  '# Histograms\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `${input}_df = pd.DataFrame(${input})\n` +
                    `${input}_df.hist(bins=20, figsize=(20, 15))\n` +
                    'plt.show()\n';
    }else if (cnn){
        var code =  '# Histograms\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `import seaborn as sns\n` +
                    `plt.figure(figsize=(20, 15))\n` +
                    `for i in range(len(train_generator.class_indices)):\n` +
                    `    plt.subplot(1, len(train_generator.class_indices), i + 1)\n` +
                    `    sns.histplot(y_true[y_true == i], bins=20, kde=False)\n` +
                    `    plt.title(f'Class {i}')\n` +
                    `plt.show()\n`;
    }
    else {
        var code =  '# Histograms\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `${input}.hist(bins=20, figsize=(20, 15))\n` +
                    'plt.show()\n';
    }
    // If there is an input value, append it to the code
    if (histograms_input) {
        code += `\n${histograms_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['box_plots'] = function(block) {
    var box_plots_input = Blockly.Python.valueToCode(block, 'box_plots', Blockly.Python.ORDER_ATOMIC) || '';
    var som = block.getFieldValue('som') === 'TRUE';

    if (som) {
        var code =  '# Box Plots for feature distribution\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `${input}_df.plot(kind=\'box\', subplots=True, layout=(5, 5), figsize=(20, 15), sharex=False, sharey=False)\n` +
                    'plt.show()\n';
    }else {
        var code =  '# Box Plots\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `${input}.plot(kind=\'box\', subplots=True, layout=(20, 20), figsize=(20, 15), sharex=False, sharey=False)\n` +
                    'plt.show()\n';
    }
    // If there is an input value, append it to the code
    if (box_plots_input) {
        code += `\n${box_plots_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['heatmaps'] = function(block) {
    var heatmaps_input = Blockly.Python.valueToCode(block, 'heatmaps', Blockly.Python.ORDER_ATOMIC) || '';
    var som = block.getFieldValue('som') === 'TRUE';
    var cnn = block.getFieldValue('cnn') === 'TRUE';

    if (som && cnn) {
        alert("You can't select two models in heatmaps visualization block");
    }

    if (som) {
        var code =  '# Heatmaps\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'import seaborn as sns\n' +
                    'plt.figure(figsize=(12, 10))\n' +
                    `sns.heatmap(${input}_df.corr(), annot=True, cmap=\'coolwarm\')\n` +
                    'plt.show()\n';
    }else if (cnn) {
        var code =  '# Heatmaps\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'import seaborn as sns\n' +
                    `import pandas as pd\n` +
                    `import numpy as np\n` +
                    `${y_test} = test_generator.classes\n` +
                    `plt.figure(figsize=(12, 10))\n` +
                    `# Note: Heatmap of feature correlation is not typically meaningful for image data\n` +
                    `# Using random data here just to show how it could be done if we had numerical features\n` +
                    `dummy_data = pd.DataFrame(np.random.rand(len(${y_test}), 10))  # Replace with your actual data if applicable\n` +
                    `sns.heatmap(dummy_data.corr(), annot=True, cmap='coolwarm')\n` +
                    `plt.title('Feature Correlation Heatmap')\n` +
                    'plt.show()\n';
    }else {
        var code =  '# Heatmaps\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'import seaborn as sns\n' +
                    'plt.figure(figsize=(12, 10))\n' +
                    `sns.heatmap(${input}.corr(), annot=True, cmap=\'coolwarm\')\n` +
                    'plt.title(\'Feature Correlation Heatmap\')\n' +
                    'plt.show()\n';
    }
    // If there is an input value, append it to the code
    if (heatmaps_input) {
        code += `\n${heatmaps_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };
/* ------------------------------ Data Visualization ends ------------------------------ */
/* ------------------------------ Model Visualization begins ------------------------------ */
Blockly.Python['decision_boundary'] = function(block) {
    var decision_boundary_input = Blockly.Python.valueToCode(block, 'decision_boundary', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Decision Boundary Plot\n' +
                '# Only for 2D data\n' +
                'import matplotlib.pyplot as plt\n' +
                'import numpy as np\n' +
                `if ${input}.shape[1] == 2:\n` +
                `    x_min, x_max = ${input}.iloc[:, 0].min() - 1, ${input}.iloc[:, 0].max() + 1\n` +
                `    y_min, y_max = ${input}.iloc[:, 1].min() - 1, ${input}.iloc[:, 1].max() + 1\n` +
                '    xx, yy = np.meshgrid(np.arange(x_min, x_max, 0.1), np.arange(y_min, y_max, 0.1))\n' +
                '    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])\n' +
                '    Z = Z.reshape(xx.shape)\n' +
                '    plt.contourf(xx, yy, Z, alpha=0.4)\n' +
                `    plt.scatter(${input}.iloc[:, 0], ${input}.iloc[:, 1], c=y, marker=\'o\', edgecolor=\'k\')\n` +
                '    plt.show()\n';

    // If there is an input value, append it to the code
    if (decision_boundary_input) {
        code += `\n${decision_boundary_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['tree_visualization'] = function(block) {
    var tree_visualization_input = Blockly.Python.valueToCode(block, 'tree_visualization', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Tree Visualization (Decision Tree Classification)\n' +
                'from sklearn.tree import DecisionTreeClassifier, plot_tree\n' +
                'import matplotlib.pyplot as plt\n' +
                '\ntree_model = DecisionTreeClassifier()\n' +
                `tree_model.fit(${x_train}, ${y_train})\n` +
                'plt.figure(figsize=(20, 10))\n' +
                `plot_tree(tree_model, filled=True, feature_names=${input}.columns, class_names=[\'0\', \'1\'])\n` +
                'plt.show()\n';

    // If there is an input value, append it to the code
    if (tree_visualization_input) {
        code += `\n${tree_visualization_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['feature_importances'] = function(block) {
    var feature_importances_input = Blockly.Python.valueToCode(block, 'feature_importances', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Feature Importances (Random Forest Classification)\n' +
                'import matplotlib.pyplot as plt\n' +
                'from sklearn.ensemble import RandomForestClassifier\n' +
                '\nrf_model = RandomForestClassifier()\n' +
                `rf_model.fit(${x_train}, ${y_train})\n` +
                'importances = rf_model.feature_importances_\n' +
                'indices = np.argsort(importances)[::-1]\n' +
                'plt.figure(figsize=(12, 8))\n' +
                'plt.title("Feature importances")\n' +
                `plt.bar(range(${input}.shape[1]), importances[indices], align="center")\n` +
                `plt.xticks(range(${input}.shape[1]), ${input}.columns[indices], rotation=90)\n` +
                `plt.xlim([-1, ${input}.shape[1]])\n` +
                'plt.show()\n';

    // If there is an input value, append it to the code
    if (feature_importances_input) {
        code += `\n${feature_importances_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['learning_curves'] = function(block) {
    var learning_curves_input = Blockly.Python.valueToCode(block, 'learning_curves', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Learning Curves for classical models\n' +
                'import matplotlib.pyplot as plt\n' +
                'from sklearn.model_selection import learning_curve\n' +
                `\ntrain_sizes, train_scores, test_scores = learning_curve(model, ${x_train}, ${y_train}, cv=5)\n` +
                'train_mean = np.mean(train_scores, axis=1)\n' +
                'test_mean = np.mean(test_scores, axis=1)\n' +
                'plt.plot(train_sizes, train_mean, label=\'Training score\')\n' +
                'plt.plot(train_sizes, test_mean, label=\'Cross-validation score\')\n' +
                'plt.xlabel(\'Training Size\')\n' +
                'plt.ylabel(\'Score\')\n' +
                'plt.legend()\n' +
                'plt.show()\n';

    // If there is an input value, append it to the code
    if (learning_curves_input) {
        code += `\n${learning_curves_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

/* ------------------------------ Model Visualization ends ------------------------------ */
/* ------------------------------ Model Performance begins ------------------------------ */
Blockly.Python['confusion_matrix'] = function(block) {
    var confusion_input = Blockly.Python.valueToCode(block, 'confusion_matrix', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Confusion Matrix for classical models\n' +
                'from sklearn.metrics import ConfusionMatrixDisplay, confusion_matrix\n' +
                'import matplotlib.pyplot as plt\n\n' +
                `cm = confusion_matrix(${y_test}, ${global_predicted_variable})\n` +
                'disp = ConfusionMatrixDisplay(confusion_matrix=cm)\n' +
                'disp.plot(cmap=\'Blues\')\n' +
                'plt.show()\n';

    // If there is an input value, append it to the code
    if (confusion_input) {
        code += `\n${confusion_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['ROC_curve'] = function(block) {
    var ROC_curve_input = Blockly.Python.valueToCode(block, 'ROC_curve', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# ROC Curve for classical models\n' +
                'from sklearn.metrics import RocCurveDisplay\n' +
                'import matplotlib.pyplot as plt\n\n' +
                `RocCurveDisplay.from_estimator(model, ${x_test}, ${y_test})\n` +
                'plt.show()\n';

    // If there is an input value, append it to the code
    if (ROC_curve_input) {
        code += `\n${ROC_curve_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['precision_recall_curve'] = function(block) {
    var recall_input = Blockly.Python.valueToCode(block, 'precision_recall_curve', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Precision-Recall Curve for classical models\n' +
                'from sklearn.metrics import PrecisionRecallDisplay\n' +
                'import matplotlib.pyplot as plt\n' +
                `PrecisionRecallDisplay.from_estimator(model, ${x_test}, ${y_test})\n` +
                'plt.show()\n';

    // If there is an input value, append it to the code
    if (recall_input) {
        code += `\n${recall_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  /* ------------------------------ Model Performance ends ------------------------------ */
  /* ------------------------------ Clustering and Dimensionality Reduction begins ------------------------------ */
  Blockly.Python['elbow_plot'] = function(block) {
      var elbow_plot_input = Blockly.Python.valueToCode(block, 'elbow_plot', Blockly.Python.ORDER_ATOMIC) || '';
  
      var code =  '# Elbow Plot\n' +
                  'from sklearn.cluster import KMeans\n' +
                  'import matplotlib.pyplot as plt\n\n' +
                  'wcss = []\n' +
                  'for i in range(1, 11):\n' +
                  '    kmeans = KMeans(n_clusters=i, random_state=42)\n' +
                  `    kmeans.fit(${input})\n` +
                  '    wcss.append(kmeans.inertia_)\n' +
                  'plt.plot(range(1, 11), wcss)\n' +
                  'plt.xlabel(\'Number of clusters\')\n' +
                  'plt.ylabel(\'WCSS\')\n' +
                  'plt.title(\'Elbow Method\')\n' +
                  'plt.show()\n';
  
      if (elbow_plot_input) {
          code += `\n${elbow_plot_input}`;
      }
  
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['tsne_plot'] = function(block) {
      var tsne_plot_input = Blockly.Python.valueToCode(block, 'tsne_plot', Blockly.Python.ORDER_ATOMIC) || '';
  
      var code =  '# TSNE Plot\n' +
                  'from sklearn.manifold import TSNE\n' +
                  'import matplotlib.pyplot as plt\n\n' +
                  '# Ensure target labels are numerical\n' +
                  `y_numeric = pd.factorize(${output})[0]\n\n` +
                  'tsne = TSNE(n_components=2, random_state=42)\n' +
                  `x_tsne = tsne.fit_transform(${input})\n` +
                  'plt.scatter(x_tsne[:, 0], x_tsne[:, 1], c=y_numeric, cmap=\'viridis\')\n' +
                  'plt.title(\'TSNE\')\n' +
                  'plt.show()\n';
  
      if (tsne_plot_input) {
          code += `\n${tsne_plot_input}`;
      }
  
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  
  Blockly.Python['pca_plot'] = function(block) {
      var pca_plot_input = Blockly.Python.valueToCode(block, 'pca_plot', Blockly.Python.ORDER_ATOMIC) || '';
  
      var code =  '# PCA Plot\n' +
                  'from sklearn.decomposition import PCA\n' +
                  'import matplotlib.pyplot as plt\n\n' +
                  'pca = PCA(n_components=2)\n' +
                  `x_pca = pca.fit_transform(${input})\n` +
                  'plt.scatter(x_pca[:, 0], x_pca[:, 1], c=y_numeric, cmap=\'viridis\')\n' +
                  'plt.title(\'PCA\')\n' +
                  'plt.show()\n';
  
      if (pca_plot_input) {
          code += `\n${pca_plot_input}`;
      }
  
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  /* ------------------------------ Clustering and Dimensionality Reduction ends ------------------------------ */
  /* ------------------------------ Hyperparameter Tuning Visualization begins ------------------------------ */
  Blockly.Python['hyperparameter_heatmaps'] = function(block) {
      var hyperparameter_heatmaps_input = Blockly.Python.valueToCode(block, 'hyperparameter_heatmaps', Blockly.Python.ORDER_ATOMIC) || '';
  
      var code =  '# Hyperparameter Heatmaps\n' +
                  'import numpy as np\n' +
                  'import matplotlib.pyplot as plt\n' +
                  'from sklearn.model_selection import GridSearchCV\n' +
                  'param_grid = {\'C\': [0.1, 1, 10, 100]}\n' +
                  'grid_search = GridSearchCV(LogisticRegression(), param_grid, cv=5)\n' +
                  `grid_search.fit(${x_train}, ${y_train})\n` +
                  'scores = grid_search.cv_results_[\'mean_test_score\'].reshape(len(param_grid[\'C\']), -1)\n' +
                  'plt.imshow(scores, interpolation=\'nearest\', cmap=\'viridis\')\n' +
                  'plt.xlabel(\'C\')\n' +
                  'plt.ylabel(\'Mean Test Score\')\n' +
                  'plt.colorbar()\n' +
                  'plt.xticks(np.arange(len(param_grid[\'C\'])), param_grid[\'C\'])\n' +
                  'plt.title(\'Hyperparameter Grid Search\')\n' +
                  'plt.show()\n';
  
      if (hyperparameter_heatmaps_input) {
          code += `\n${hyperparameter_heatmaps_input}`;
      }
  
      return [code, Blockly.Python.ORDER_ATOMIC];
  };
  /* ------------------------------ Hyperparameter Tuning Visualization ends ------------------------------ */
  /* ------------------------------ Neural Network begins ------------------------------ */
  Blockly.Python['confusion_matrix_nn'] = function(block) {
    var confusion_nn_input = Blockly.Python.valueToCode(block, 'confusion_matrix_nn', Blockly.Python.ORDER_ATOMIC) || '';
    var som = block.getFieldValue('som') === 'TRUE';
    var cnn = block.getFieldValue('cnn') === 'TRUE';

    if (som && cnn) {
        alert("You can't select two models in Confusion Matrix visualization block");
    }
    if (som) {
        var code =  '\n# Confusion Matrix for neural network models\n' +
                    'from sklearn.metrics import confusion_matrix\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'import seaborn as sns\n' +
                    `cm = confusion_matrix(${y_test}, ${global_predicted_variable})\n` +
                    'plt.figure(figsize=(8, 6))\n' +
                    'sns.heatmap(cm, annot=True, fmt=\'d\', cmap=\'Oranges\', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)\n' +
                    'plt.title(\'Confusion Matrix\')\n' +
                    'plt.xlabel(\'Predicted labels\')\n' +
                    'plt.ylabel(\'True labels\')\n' +
                    'plt.show()\n';
    }else if (cnn) {
        var code =  '\n# Confusion Matrix for neural network models\n' +
                    'from sklearn.metrics import confusion_matrix\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'import seaborn as sns\n' +
                    `import numpy as np\n` +
                    `${y_test} = test_generator.classes\n` +
                    `y_pred_prob = model.predict(test_generator)\n` +
                    `${global_predicted_variable} = np.argmax(y_pred_prob, axis=1)\n` +
                    `cm = confusion_matrix(${y_test}, ${global_predicted_variable})\n` +
                    'plt.figure(figsize=(8, 6))\n' +
                    'sns.heatmap(cm, annot=True, fmt=\'d\', cmap=\'Oranges\')\n' +
                    'plt.title(\'Confusion Matrix\')\n' +
                    'plt.xlabel(\'Predicted labels\')\n' +
                    'plt.ylabel(\'True labels\')\n' +
                    'plt.show()\n';
    }else {
        var code =  '# Confusion Matrix for neural network models\n' +
                    'from sklearn.metrics import confusion_matrix\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'import seaborn as sns\n' +
                    `${global_predicted_variable} = (model.predict(${x_test}) > 0.5).astype("int32")\n` +
                    `cm = confusion_matrix(${y_test}, ${global_predicted_variable})\n` +
                    'plt.figure(figsize=(8, 6))\n' +
                    'sns.heatmap(cm, annot=True, fmt=\'d\', cmap=\'Oranges\', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)\n' +
                    'plt.title(\'Confusion Matrix\')\n' +
                    'plt.xlabel(\'Predicted labels\')\n' +
                    'plt.ylabel(\'True labels\')\n' +
                    'plt.show()\n';
    }
    // If there is an input value, append it to the code
    if (confusion_nn_input) {
        code += `\n${confusion_nn_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['ROC_curve_nn'] = function(block) {
    var ROC_nn_input = Blockly.Python.valueToCode(block, 'ROC_curve_nn', Blockly.Python.ORDER_ATOMIC) || '';
    var som = block.getFieldValue('som') === 'TRUE';

    if (som) {
    var code =      '\n# ROC Curve for neural network models\n' +
                    'from sklearn.metrics import auc, roc_curve\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `fpr, tpr, _ = roc_curve(${y_test}, ${global_predicted_variable})\n` +
                    'roc_auc = auc(fpr, tpr)\n' +
                    'plt.figure()\n' +
                    'plt.plot(fpr, tpr, color=\'darkorange\', lw=2, label=\'ROC curve (area = %0.2f)\' % roc_auc)\n' +
                    'plt.plot([0, 1], [0, 1], color=\'navy\', lw=2, linestyle=\'--\')\n' +
                    'plt.xlim([0.0, 1.0])\n' +
                    'plt.ylim([0.0, 1.05])\n' +
                    'plt.xlabel(\'False Positive Rate\')\n' +
                    'plt.ylabel(\'True Positive Rate\')\n' +
                    'plt.title(\'Receiver Operating Characteristic\')\n' +
                    'plt.legend(loc="lower right")\n' +
                    'plt.show()\n';
    }else {
        var code =  '# ROC Curve for neural network models\n' +
                    'from sklearn.metrics import auc\n' +
                    'from sklearn.metrics import RocCurveDisplay\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `${global_predicted_variable} = model.predict(${x_test}).ravel()\n` +
                    `fpr, tpr, _ = roc_curve(${y_test}, ${global_predicted_variable})\n` +
                    'roc_auc = auc(fpr, tpr)\n' +
                    'plt.figure()\n' +
                    'plt.plot(fpr, tpr, color=\'darkorange\', lw=2, label=\'ROC curve (area = %0.2f)\' % roc_auc)\n' +
                    'plt.plot([0, 1], [0, 1], color=\'navy\', lw=2, linestyle=\'--\')\n' +
                    'plt.xlim([0.0, 1.0])\n' +
                    'plt.ylim([0.0, 1.05])\n' +
                    'plt.xlabel(\'False Positive Rate\')\n' +
                    'plt.ylabel(\'True Positive Rate\')\n' +
                    'plt.title(\'Receiver Operating Characteristic\')\n' +
                    'plt.legend(loc="lower right")\n' +
                    'plt.show()\n';
    }
    // If there is an input value, append it to the code
    if (ROC_nn_input) {
        code += `\n${ROC_nn_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['precision_recall_curve_nn'] = function(block) {
    var recall_nn_input = Blockly.Python.valueToCode(block, 'precision_recall_curve_nn', Blockly.Python.ORDER_ATOMIC) || '';
    var som = block.getFieldValue('som') === 'TRUE';

    if (som) {
        var code =  '\n# Precision-Recall Curve for neural network models\n' +
                    'from sklearn.metrics import PrecisionRecallDisplay, precision_recall_curve\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `precision, recall, _ = precision_recall_curve(${y_test}, ${global_predicted_variable})\n` +
                    `disp = PrecisionRecallDisplay(precision=precision, recall=recall)\n` +
                    `disp.plot()\n` +
                    'plt.show()\n';
    }else {
        var code =  '# Precision-Recall Curve for neural network models\n' +
                    'from sklearn.metrics import precision_recall_curve\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `precision, recall, _ = precision_recall_curve(${y_test}, ${global_predicted_variable})\n` +
                    'plt.figure()\n' +
                    'plt.plot(recall, precision, color=\'b\', lw=2)\n' +
                    'plt.xlabel(\'Recall\')\n' +
                    'plt.ylabel(\'Precision\')\n' +
                    'plt.title(\'Precision-Recall Curve\')\n' +
                    'plt.show()\n';
    }
    // If there is an input value, append it to the code
    if (recall_nn_input) {
        code += `\n${recall_nn_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['loss_accuracy_curve'] = function(block) {
    var loss_accuracy_input = Blockly.Python.valueToCode(block, 'loss_accuracy_curve', Blockly.Python.ORDER_ATOMIC) || '';
    var numerical = block.getFieldValue('Numerical') === 'TRUE';
    var cnn = block.getFieldValue('cnn') === 'TRUE';

    if (numerical && cnn) {
        alert("You can't select two models in loss and accuracy curve visualization block");
    }

    if (numerical) {
        var code =  '\n# Numerical Loss and Accuracy Curves for neural network models\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `plt.plot(history.history['loss'], label='train_loss')\n` +
                    `plt.plot(history.history['val_loss'], label='val_loss')\n` +
                    `plt.xlabel('Epochs')\n` +
                    `plt.ylabel('Loss')\n` +
                    `plt.title('Training and Validation Loss')\n` +
                    `plt.legend()\n` +
                    'plt.show()\n';
    }else if (cnn) {
        var code =  '\n# # Plot training & validation loss values\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `plt.figure()\n` +
                    `plt.plot(history.history['loss'], label='train_loss')\n` +
                    `if 'val_loss' in history.history:\n` +
                    `    plt.plot(history.history['val_loss'], label='val_loss')\n` +
                    `plt.xlabel('Epochs')\n` +
                    `plt.ylabel('Loss')\n` +
                    `plt.title('Training and Validation Loss')\n` +
                    `plt.legend()\n` +
                    'plt.show()\n\n' +
                    `# Plot training & validation accuracy values\n` +
                    `plt.figure()\n` +
                    `plt.plot(history.history['accuracy'], label='train_accuracy')\n` +
                    `if 'val_accuracy' in history.history:\n` +
                    `    plt.plot(history.history['val_accuracy'], label='val_accuracy')\n` +
                    `plt.xlabel('Epochs')\n` +
                    `plt.ylabel('Accuracy')\n` +
                    `plt.title('Training and Validation Accuracy')\n` +
                    `plt.legend()\n` +
                    'plt.show()\n';
    }else {

        var code =  '# Loss and Accuracy Curves for neural network models\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'plt.figure()\n' +
                    'plt.plot(history.history[\'loss\'], label=\'train_loss\')\n' +
                    'plt.plot(history.history[\'val_loss\'], label=\'val_loss\')\n' +
                    'plt.xlabel(\'Epochs\')\n' +
                    'plt.ylabel(\'Loss\')\n' +
                    'plt.title(\'Training and Validation Loss\')\n' +
                    'plt.legend()\n' +
                    'plt.show()\n\n' +
                    'plt.figure()\n' +
                    'plt.plot(history.history[\'accuracy\'], label=\'train_accuracy\')\n' +
                    'plt.plot(history.history[\'val_accuracy\'], label=\'val_accuracy\')\n' +
                    'plt.xlabel(\'Epochs\')\n' +
                    'plt.ylabel(\'Accuracy\')\n' +
                    'plt.title(\'Training and Validation Accuracy\')\n' +
                    'plt.legend()\n' +
                    'plt.show()\n';
    }
    // If there is an input value, append it to the code
    if (loss_accuracy_input) {
        code += `\n${loss_accuracy_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['learning_curves_nn'] = function(block) {
    var learning_curves_input = Blockly.Python.valueToCode(block, 'learning_curves_nn', Blockly.Python.ORDER_ATOMIC) || '';
    var cnn = block.getFieldValue('cnn') === 'TRUE';

    if (cnn) {
        var code =  '\n# Learning Curves for neural network models\n' +
                    'import matplotlib.pyplot as plt\n' +
                    `import numpy as np\n` +
                    `train_sizes = np.linspace(0.1, 1.0, 10)\n` +
                    `train_scores = []\n` +
                    `test_scores = []\n` +
                    `for train_size in train_sizes:\n` +
                    `    ${x_train}_subset, ${y_train}_subset = next(train_generator)\n\n` +
                    `    model.fit(${x_train}_subset, ${y_train}_subset, epochs=10, verbose=0)\n` +
                    `    train_loss, train_acc = model.evaluate(${x_train}_subset, ${y_train}_subset, verbose=0)\n` +
                    `    test_loss, test_acc = model.evaluate(test_generator, verbose=0)\n\n` +
                    `    train_scores.append(train_loss)\n` +
                    `    test_scores.append(test_loss)\n\n` +
                    `plt.figure()\n` +
                    `plt.plot(train_sizes, train_scores, label='Training loss')\n` +
                    `plt.plot(train_sizes, test_scores, label='Validation loss')\n` +
                    `plt.xlabel('Training Size')\n` +
                    `plt.ylabel('Loss')\n` +
                    `plt.title('Learning Curves')\n` +
                    `plt.legend()\n` +
                    'plt.show()\n';
    }else {
        var code =  `\n# Learning Curves for neural network models\n` +
                    `train_sizes = np.linspace(0.1, 1.0, 10)\n` +
                    `train_scores = []\n` +
                    `test_scores = []\n` +
                    `for train_size in train_sizes:\n` +
                    `    ${x_train}_subset = ${x_train}[:int(train_size * len(${x_train}))]\n` +
                    `    ${y_train}_subset = ${y_train}[:int(train_size * len(${y_train}))]\n\n` +
                    `    model.fit(${x_train}_subset, ${y_train}_subset, epochs=10, verbose=0)\n` +
                    `    train_loss = model.evaluate(${x_train}_subset, ${y_train}_subset, verbose=0)\n` +
                    `    test_loss = model.evaluate(${x_test}, ${y_test}, verbose=0)\n\n` +
                    `    train_scores.append(train_loss)\n` +
                    `    test_scores.append(test_loss)\n\n` +
                    `plt.figure()\n` +
                    `plt.plot(train_sizes, train_scores, label='Training loss')\n` +
                    `plt.plot(train_sizes, test_scores, label='Validation loss')\n` +
                    `plt.xlabel('Training Size')\n` +
                    `plt.ylabel('Loss')\n` +
                    `plt.title('Learning Curves')\n` +
                    `plt.legend()\n` +
                    `plt.show()\n`;
    }
    // If there is an input value, append it to the code
    if (learning_curves_input) {
        code += `\n${learning_curves_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

  Blockly.Python['word_cloud'] = function(block) {
    var word_cloud_input = Blockly.Python.valueToCode(block, 'word_cloud', Blockly.Python.ORDER_ATOMIC) || '';
    
        var code =  '# Word Cloud\n' +
                    'import matplotlib.pyplot as plt\n' +
                    'from wordcloud import WordCloud\n' +
                    'wordcloud = WordCloud().generate(text_data)\n' +
                    'plt.figure()\n' +
                    'plt.imshow(wordcloud, interpolation=\'bilinear\')\n' +
                    'plt.axis(\'off\')\n' +
                    'plt.title(\'Word Cloud\')\n' +
                    'plt.show()';

    // If there is an input value, append it to the code
    if (word_cloud_input) {
        code += `\n${word_cloud_input}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };
/* ------------------------------ Neural Network ends ------------------------------ */
/* ------------------------------ Ensemble Methods Visualization begins ------------------------------ */
Blockly.Python['ensemble_feature_importance'] = function(block) {
    var ensemble_feature_importance_input = Blockly.Python.valueToCode(block, 'ensemble_feature_importance', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Feature Importance from Ensemble Methods\n' +
                'import matplotlib.pyplot as plt\n' +
                'import numpy as np\n' +
                'from sklearn.ensemble import RandomForestClassifier\n' +
                'model = RandomForestClassifier()\n' +
                `model.fit(${x_train}, ${y_train})\n` +
                'importances = model.feature_importances_\n' +
                'indices = np.argsort(importances)[::-1]\n' +
                'plt.figure()\n' +
                'plt.title("Feature Importances")\n' +
                `plt.bar(range(${x_train}.shape[1]), importances[indices], align="center")\n` +
                `plt.xticks(range(${x_train}.shape[1]), ${x_train}.columns[indices], rotation=90)\n` +
                'plt.tight_layout()\n' +
                'plt.show()\n';

    if (ensemble_feature_importance_input) {
        code += `\n${ensemble_feature_importance_input}`;
    }

    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['oob_error_plot'] = function(block) {
    var oob_error_plot_input = Blockly.Python.valueToCode(block, 'oob_error_plot', Blockly.Python.ORDER_ATOMIC) || '';

    var code =  '# Out-of-Bag Error\n' +
                'import matplotlib.pyplot as plt\n' +
                'from sklearn.ensemble import RandomForestClassifier\n' +
                '# Create a list to store OOB errors\n' +
                'oob_errors = []\n\n' +
                '# Iterate over a range of n_estimators\n' +
                'for n_estimators in range(1, 101):\n' +
                '    model = RandomForestClassifier(n_estimators=n_estimators, oob_score=True)\n' +
                `    model.fit(${x_train}, ${y_train})\n` +
                '    oob_error = 1 - model.oob_score_\n' +
                '    oob_errors.append(oob_error)\n\n' +
                '# Plot the OOB error\n' +
                'plt.plot(range(1, 101), oob_errors, label="OOB Error")\n' +
                'plt.xlabel("Number of Trees")\n' +
                'plt.ylabel("OOB Error")\n' +
                'plt.title("Out-of-Bag Error")\n' +
                'plt.legend()\n' +
                'plt.show()\n';

    if (oob_error_plot_input) {
        code += `\n${oob_error_plot_input}`;
    }

    return [code, Blockly.Python.ORDER_ATOMIC];
};
/* ------------------------------ Ensemble Methods Visualization ends ------------------------------ */
/* end visualization blocks */



///////////////////////////////////////////////////////
function modifyLastRnnLayer(layers) {

    const layerArray = layers.split('\n').map(line => line.trim());
  
    for (let i = layerArray.length - 1; i >= 0; i--) {
      if (
        layerArray[i].startsWith('SimpleRNN') ||
        layerArray[i].startsWith('LSTM') ||
        layerArray[i].startsWith('GRU')
      ) {

        layerArray[i] = layerArray[i].replace('return_sequences=True', 'return_sequences=False');
        break; 
      }
    }
    return layerArray.join('\n');
  }
// var layersFlag = [];
var globalVocab_size= 10000;
var globalMaxlen= 100;
var globalVocabEmbeddingDim = 32;

Blockly.Python['rnn_model'] = function(block) {
    var trainPath = block.getFieldValue('trainPath');
    var testPath = block.getFieldValue('testPath');
    var inputColumn = block.getFieldValue('inputColumn');
    var targetColumn = block.getFieldValue('targetColumn');
    var vocab_size = block.getFieldValue('vocab_size');
    var maxlen = block.getFieldValue('maxlen');
    var embedding_dim = block.getFieldValue('embedding_dim');
    var layers = Blockly.Python.valueToCode(block, 'layers', Blockly.Python.ORDER_ATOMIC) || '';
    var compile = Blockly.Python.valueToCode(block, 'model_compile', Blockly.Python.ORDER_ATOMIC) || '';
    var fit = Blockly.Python.valueToCode(block, 'model_fit', Blockly.Python.ORDER_ATOMIC) || '';
    var evaluation = Blockly.Python.valueToCode(block, 'Model_Evaluation', Blockly.Python.ORDER_ATOMIC) || '';
    var visualization = Blockly.Python.valueToCode(block, 'Visualization', Blockly.Python.ORDER_ATOMIC) || '';
    
    globalVocab_size= vocab_size;
    globalMaxlen= maxlen;
    globalVocabEmbeddingDim = embedding_dim;

    if(!layers){
        alert("Add layers block");
    }
    if(!compile){
        alert("Add compile block");
    }
    if(!fit){
        alert("Add fit block");
    }
    var code = `
import pandas as pd
import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.utils import to_categorical
from sklearn.preprocessing import LabelEncoder\n`

if (layers && layersFlag.includes("Embedding")) { code += 'from tensorflow.keras.layers import Embedding\n'; }
if (layers && layersFlag.includes("Simple_RNN")) { code += 'from tensorflow.keras.layers import SimpleRNN\n'; }
if (layers && layersFlag.includes("LSTM")) { code += 'from tensorflow.keras.layers import LSTM\n'; }
if (layers && layersFlag.includes("GRU")) { code += 'from tensorflow.keras.layers import GRU\n'; }
if (layers && layersFlag.includes("Dense")) { code += 'from tensorflow.keras.layers import Dense\n'; }
if (layers && layersFlag.includes("dropout")) { code += 'from tensorflow.keras.layers import Dropout\n'; }
code+=
`
train_df = pd.read_csv('${trainPath}')
test_df = pd.read_csv('${testPath}')


X_train = train_df['${inputColumn}'].values
y_train = train_df['${targetColumn}'].values
X_test = test_df['${inputColumn}'].values
y_test = test_df['${targetColumn}'].values

label_encoder = LabelEncoder()
y_train = label_encoder.fit_transform(y_train)
y_test = label_encoder.transform(y_test)

tokenizer = Tokenizer(num_words=${vocab_size})
tokenizer.fit_on_texts(X_train)

X_train = tokenizer.texts_to_sequences(X_train)
X_test = tokenizer.texts_to_sequences(X_test)
X_train = pad_sequences(X_train, maxlen=${maxlen})
X_test = pad_sequences(X_test, maxlen=${maxlen})


num_classes = len(np.unique(y_train))
y_train = to_categorical(y_train, num_classes=num_classes)
y_test = to_categorical(y_test, num_classes=num_classes)\n`;

if(layers){
    var layer =`model = Sequential([\n`
    layer+= `${layers}`
    layer +=`\n])\n`
}

code+= modifyLastRnnLayer(layer)
code+=compile
code+=fit
code+=evaluation
code+=visualization
    return code;
};


Blockly.Python['embedding'] = function(block) {

    var next_layer = Blockly.Python.valueToCode(block, 'nextLayer', Blockly.Python.ORDER_ATOMIC) || '';

    if (!layersFlag.includes("Embedding")) {
        layersFlag.push("Embedding");
    }

    var code = `Embedding(${globalVocab_size}, ${globalVocabEmbeddingDim}, input_length=${globalMaxlen})`;
    if (next_layer) {
        code += `,\n${next_layer}`;
    }

    return [code, Blockly.Python.ORDER_ATOMIC];
};



Blockly.Python['gru'] = function(block) {
    var units = block.getFieldValue('units');
    var activation = block.getFieldValue('activation');
    var next_layer = Blockly.Python.valueToCode(block, 'nextLayer', Blockly.Python.ORDER_ATOMIC) || '';

    if (!layersFlag.includes("GRU")) {
        layersFlag.push("GRU");
    }

    var code = `GRU(${units}, activation='${activation}',return_sequences=True)`;
    if (next_layer) {
        code += `,\n${next_layer}`;
    }
    return [code, Blockly.Python.ORDER_ATOMIC];
};



Blockly.Python['lstm'] = function(block) {
    var units = block.getFieldValue('units');
    var activation = block.getFieldValue('activation');
    var next_layer = Blockly.Python.valueToCode(block, 'nextLayer', Blockly.Python.ORDER_ATOMIC) || '';

    if (!layersFlag.includes("LSTM")) {
        layersFlag.push("LSTM");
    }

    var code = `LSTM(${units}, activation='${activation}',return_sequences=True)`;
    if (next_layer) {
        code += `,\n${next_layer}`;
    }
    return [code, Blockly.Python.ORDER_ATOMIC];
};



Blockly.Python['simple_rnn'] = function(block) {
    var units = block.getFieldValue('units');
    var activation = block.getFieldValue('activation');
    var input = Blockly.Python.valueToCode(block, 'nextLayer', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `SimpleRNN(${units}, activation='${activation}',return_sequences=True)`;
    if (input) {
        code += `,\n${input}`;
    }
    if (!layersFlag.includes("Simple_RNN")) {
        layersFlag.push("Simple_RNN");
    }
    return [code, Blockly.Python.ORDER_ATOMIC];
};


    
Blockly.Python['kmeans_clustering'] = function(block) {
        var dataset_path = block.getFieldValue('dataset_path');
        var data_preprocessing = Blockly.Python.valueToCode(block, 'data_preprocessing', Blockly.Python.ORDER_ATOMIC) || '';
        var model_training = Blockly.Python.valueToCode(block, 'model_training', Blockly.Python.ORDER_ATOMIC) || '';
        var model_evaluation = Blockly.Python.valueToCode(block, 'model_evaluation', Blockly.Python.ORDER_ATOMIC) || '';
        var model_Prediction = Blockly.Python.valueToCode(block, 'model_Prediction', Blockly.Python.ORDER_ATOMIC) || '';
        var visualization = Blockly.Python.valueToCode(block, 'visualization', Blockly.Python.ORDER_ATOMIC) || '';
        var hyperparameters = block.getFieldValue('hyperparameters');

        if(!data_preprocessing){
            alert("Add preprocess block");
        }
        if(!model_training){
            alert("Add training block");
        }
    
        var code = `import pandas as pd\n`;
        code += `from sklearn.cluster import KMeans\n`;
        code += `\n`;
        code += `data = pd.read_csv('${dataset_path}')\n`;
        code += `\n`;
        code += data_preprocessing + '\n'; 
        code += `\n`;
        code += `# Initialize KMeans model\n`;
        code += `model = KMeans(n_clusters= ${hyperparameters} , random_state=42)\n`; 
        code += `\n`;
        code += model_training + '\n';  
        code += `\n`;
        code += model_evaluation + '\n';  
    
     

        // Add model prediction code if provided
         if (model_Prediction) {
            code += `${model_Prediction}\n\n`;
        }

        // Add visualization code if provided
        if (visualization) {
            code += `${visualization}\n\n`;
        }

        // make sure that only correct visualization has been added
    var wrong = [
        "# Decision Boundary Plot",
        "# Tree Visualization (Decision Tree Classification)",
        "# Feature Importances (Random Forest Classification)",
        "# Confusion Matrix for classical models",
        "# ROC Curve for classical models",
        "# Confusion Matrix for neural network models",
        "# ROC Curve for neural network models",
        "# Precision-Recall Curve for classical models",
        "# Loss and Accuracy Curves for neural network models",
        "# Word Cloud",
        "# Feature Importance from Ensemble Methods",
        "# Out-of-Bag Error"
    ];

    function containsAnySentence(value, sentences) {
        for (var i = 0; i < sentences.length; i++) {
            if (value.includes(sentences[i])) {
                return true;
            }
        }
        return false;
    }

    if (containsAnySentence(visualization, wrong)) {
        alert("these visualizations can not be used with Kmeans Model:\nDecision Boundary Plot, Tree Visualization, Feature Importances, Precision-Recall Curve\nfor neural network models, Ensemble Methods");
    }

        return code;
};

     Blockly.Python['unsupervised_training'] = function(block) {
        var text_training_input = block.getFieldValue('Training_input');
        var code = `model.fit(${text_training_input})\n`;

        if(text_training_input != x_train){
            alert("Wrong input : "+ text_training_input);
        }

        return [code, Blockly.Python.ORDER_ATOMIC];
};
Blockly.Python['Unsuper_evaluation'] = function(block) {
    var text_training_input = block.getFieldValue('predicted_variable');
    global_predicted_variable = text_training_input ;
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `${text_training_input}= model.predict(${x_test}) \n`;
    code += value_metric +'\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
}; 

Blockly.Python['one_hot_encoding'] = function(block) {
    var column_name = block.getFieldValue('COLUMN_NAME');
    var next_block_code = Blockly.Python.valueToCode(block, 'nextblock', Blockly.Python.ORDER_ATOMIC) || '';
  
    var code = `data = pd.get_dummies(data, columns=['${column_name}'])\n` + next_block_code;
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['label_encoding'] = function(block) {
    var next_block_code = Blockly.Python.valueToCode(block, 'label_encoding', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code =  `from sklearn.preprocessing import LabelEncoder\n` +
                `import numpy as np\n` +
                `# Encode string columns in features\n` +
                `label_encoders = {}\n` +
                `for col in ${input}.columns:\n` +
                `    if ${input}[col].dtype == 'object':\n` +
                `        label_encoders[col] = LabelEncoder()\n` +
                `        ${input}[col] = label_encoders[col].fit_transform(${input}[col])\n\n` +
                `# Encode target column if it contains strings\n` +
                `if ${output}.dtype == 'object':\n` +
                `    label_encoders['${target_column}'] = LabelEncoder()\n` +
                `    ${output} = label_encoders['${target_column}'].fit_transform(${output})\n\n` +
                `# Convert to numpy arrays\n` +
                `${input} =  ${input}.values\n\n`;
    
    // If there is an input value, append it to the code
    if (next_block_code) {
        code += `\n${next_block_code}`;
      }

    return [code, Blockly.Python.ORDER_ATOMIC];
  };

Blockly.Python['remove_null_values'] = function(block) {
    var next_block_code = Blockly.Python.valueToCode(block, 'nextblock', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `data = data.dropna()\n` + next_block_code;
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['handle_missing_data'] = function(block) {
    var strategy = block.getFieldValue('strategy');
    var next_block_code = Blockly.Python.valueToCode(block, 'nextblock', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.impute import SimpleImputer\n`;
    code += `imputer = SimpleImputer(strategy='${strategy}')\n`;
    code += `data = pd.DataFrame(imputer.fit_transform(data), columns=data.columns)\n` + next_block_code;
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['remove_duplicates'] = function(block) {
    var next_block_code = Blockly.Python.valueToCode(block, 'nextblock', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `data = data.drop_duplicates()\n` + next_block_code;
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['remove_outliers'] = function(block) {
    var column_name = block.getFieldValue('COLUMN_NAME');
    var method = block.getFieldValue('method');
    var next_block_code = Blockly.Python.valueToCode(block, 'nextblock', Blockly.Python.ORDER_ATOMIC) || '';
    
    var code = "";
    if (method === "IQR") {
        code += `Q1 = data['${column_name}'].quantile(0.25)\n`;
        code += `Q3 = data['${column_name}'].quantile(0.75)\n`;
        code += `IQR = Q3 - Q1\n`;
        code += `data = data[~((data['${column_name}'] < (Q1 - 1.5 * IQR)) | (data['${column_name}'] > (Q3 + 1.5 * IQR)))]\n`;
    } else if (method === "Z-score") {
        code += `from scipy import stats\n`;
        code += `data = data[(np.abs(stats.zscore(data['${column_name}'])) < 3)]\n`;
    }
    
    code += next_block_code;
    return [code, Blockly.Python.ORDER_ATOMIC];
};
  
      
Blockly.Python['silhouette_score'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import silhouette_score\n`;
    code += `silhouette = silhouette_score(${x_test}, ${global_predicted_variable})\n`;
    code += `print(f'Silhouette Score: {silhouette}')\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};

Blockly.Python['davies_bouldin_index'] = function(block) {
    var value_metric = Blockly.Python.valueToCode(block, 'metric', Blockly.Python.ORDER_ATOMIC) || '';
    var code = `from sklearn.metrics import davies_bouldin_score\n`;
    code += `davies_bouldin = davies_bouldin_score(${x_test}, ${global_predicted_variable})\n`;
    code += `print(f'Davies-Bouldin Index: {davies_bouldin}')\n`;
    code += value_metric + '\n';
    return [code, Blockly.Python.ORDER_ATOMIC];
};